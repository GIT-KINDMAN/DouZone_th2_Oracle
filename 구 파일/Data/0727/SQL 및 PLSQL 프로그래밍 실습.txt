** 관계형 데이터베이스 기초 실습 **

===============================
            목 차 
===============================
실습 1. 기본 SELECT
실습 2. 데이터 제한 및 정렬
실습 3. 단일 행 함수
실습 4. 그룹 함수
실습 5. 조인
실습 6. 서브쿼리
실습 7. DML
실습 8. 테이블/인덱스 생성 및 관리
실습 9. 제약조건
실습 10. 뷰 생성
실습 11. 시퀀스, 동의어
실습 12. 사용자 액세스 제어
실습 13. PL/SQL 소개
실습 14. PL/SQL 변수 선언	
실습 15. 실행문 작성
실습 16. ORACLE 서버와 상호 작용
실습 17. 제어 구조 작성
실습 18. 조합 데이터 유형	
실습 19. 명시적 커서 사용	
실습 20. 예외 처리
실습 21. 내장 프로시저 생성	
실습 22. 내장 함수 생성
실습 23. 패키지 생성
실습 24. 패키지 작업
실습 25. PL/SQL 코드 설계 고려 사항	
실습 26. 트리거 생성
실습 28. 종속성 관리

===============================
실습 1. 기본 SELECT
===============================

1. Database 접속

   Putty를 사용하여 192.168.56.200으로 접속한다.

   login as: oracle

   oracle@192.168.56.200's password: oracle <-- 패스워드 입력이 화면에 표시되지 않음

   [oracle@ocpdba ~]$ sqlplus / as sysdba

   SQL> startup
   ORACLE instance started.

   Total System Global Area 318046208 bytes
   Fixed Size 1336260 bytes
   Variable Size 138415164 bytes
   Database Buffers 171966464 bytes
   Redo Buffers 6328320 bytes
   Database mounted.
   Database opened.

   SQL> conn hr/hr


2. 다음 SELECT 문은 성공적으로 실행되는가? 
   
   True

   SELECT last_name, job_id, salary AS Sal
   FROM   employees;


3. 다음 SELECT 문은 성공적으로 실행되는가? 
   
   True

   SELECT * 
   FROM   jobs;


4. 이 문장에는 코딩 오류가 네 개 있다. 식별하시오.

   SELECT employee_id, last_name
          sal x 12  ANNUAL SALARY
   FROM      employees;

   1) EMPLOYEES 테이블에는 sal이라는 컬럼이 없다. 해당 컬럼의 이름은 SALARY이다.
   2) 곱하기 연산자는 2번 줄에 나타나 있는 x가 아니라 *이다.
   3) 별칭 ANNUAL SALARY는 공백을 포함할 수 없다. ANNUAL_SALARY로 쓰거나 큰 따옴표로 묶어야한다.
   4) last_name 컬럼 다음에 쉼표가 없다.


5. DEPARTMENTS 테이블의 구조를 표시하고 테이블의 모든 데이터를 선택한다.

   DESCRIBE departments

   SELECT * FROM departments;


6. EMPLOYEES 테이블의 구조를 표시한다.
   사원 번호가 가장 앞에 오고, 이어서 각 사원의 이름, 업무 코드, 입사일이 오도록 질의를 작성한다.
   HIRE_DATE 열에 STARTDATE라는 별칭을 지정한다. 

   DESCRIBE employees
	  
   SELECT employee_id, last_name, job_id, hire_date StartDate
   FROM   employees;


7. EMPLOYEES 테이블의 업무 코드를 중복되지 않게 표시하는 질의를 작성한다.

   SELECT DISTINCT job_id 
   FROM   employees;


8. 열 머리글을 각각 Emp #, Employee, Job 및 Hire Date로 명명한 다음 질의를 실행한다.

   SELECT employee_id "Emp #", last_name "Employee",
          job_id "Job", hire_date "Hire Date"
   FROM   employees;


9. 업무 ID와 이름을 연결한 다음 쉼표 및 공백으로 구분하여 표시하고,
    열 이름을 Employee and Title로 지정한다.

    SELECT last_name||', '||job_id "Employee and Title"
    FROM   employees;


10. EMPLOYEES 테이블의 모든 데이터를 표시하는 질의를 작성한다. 
    각 열은 쉼표로 구분하고 열 이름은 THE_OUTPUT으로 지정한다.

    SELECT employee_id || ',' || first_name || ',' || last_name 
           || ',' || email || ',' || phone_number || ','|| job_id
           || ',' || manager_id || ',' || hire_date || ',' || 
           salary || ',' || commission_pct || ',' || department_id 
           THE_OUTPUT
    FROM   employees;


===============================
실습 2. 데이터 제한 및 정렬
===============================

1. 급여가 $12,000를 넘는 사원의 이름과 급여를 표시하는 질의를 작성한다.

   SELECT  last_name, salary
   FROM    employees     
   WHERE   salary > 12000;


2. 사원 번호가 176인 사원의 이름과 부서 번호를 표시하는 질의를 작성한다.

   SELECT  last_name, department_id      
   FROM    employees
   WHERE   employee_id = 176;


3. 급여가 $5,000에서 $12,000 사이에 포함되지 않는 모든 사원의 
   이름과 급여를 표시하도록 질의를 작성한다.

   SELECT  last_name, salary      
   FROM    employees     
   WHERE   salary NOT BETWEEN 5000 AND 12000;


4. 2007년 2월 7일과 2007년 5월 24일 사이에 입사한 사원의 이름, 업무 ID 및 시작일을 표시하되, 
   시작일을 기준으로 오름차순으로 정렬한다.

   SELECT   last_name, job_id, hire_date
   FROM     employees
   WHERE    hire_date BETWEEN '07-Feb-2007' AND '24-May-2007'
   ORDER BY hire_date;


5. 부서 20 및 50에 속하는 모든 사원의 이름과 부서 번호를 이름을 기준으로 영문자순으로 표시한다.
              
   SELECT   last_name, department_id      
   FROM     employees     
   WHERE    department_id IN (20, 50)      
   ORDER BY last_name;


6. 급여가 $5,000와 $12,000 사이이고 부서 번호가 20 또는 50인 사원의 이름과 급여를 
   나열하도록 질의를 작성한다.

   SELECT   last_name "Employee", salary "Monthly Salary"    
   FROM     employees     
   WHERE    salary  BETWEEN 5000 AND 12000  AND department_id IN (20, 50);


7. 2004년에 입사한 모든 사원의 이름과 입사일을 표시한다.

   SELECT   last_name, hire_date      
   FROM     employees     
   WHERE    hire_date LIKE '%04';


8. 관리자가 없는 모든 사원의 이름과 업무를 표시한다.

   SELECT   last_name, job_id      
   FROM     employees      
   WHERE    manager_id IS NULL;


9. 커미션을 받는 모든 사원의 이름, 급여 및 커미션을 급여 및 커미션을 기준으로 
   내림차순으로 정렬하여 표시한다.

   SELECT   last_name, salary, commission_pct      
   FROM     employees      
   WHERE    commission_pct IS NOT NULL     
   ORDER BY salary DESC, commission_pct DESC;


===============================
실습 3. 단일 행 함수
===============================

1. 현재 날짜를 표시하는 질의를 작성하고 열 레이블을 Date로 지정한다.

   SELECT   sysdate "Date"      
   FROM     dual;


2. 각 사원에 대해 사원 번호, 이름, 급여 및 15% 인상된 급여를 정수로 표시한다. 
   인상된 급여 열의 레이블을 New Salary로 지정한다.

   SELECT   employee_id, last_name, salary,
            ROUND(salary * 1.15, 0) "New Salary"      
   FROM     employees;


3. 이름이 J, A 또는 M으로 시작하는 모든 사원의 이름(첫 글자는 대문자로, 나머지 글자는 소문자로 표시) 
   및 이름 길이를 표시하는 질의를 작성하고 각 열에 적합한 레이블을 지정한다. 
   결과를 사원의 이름에 따라 정렬한다.

   SELECT   INITCAP(last_name) "Name", LENGTH(last_name) "Length"      
   FROM     employees      
   WHERE    last_name LIKE 'J%' OR last_name LIKE 'M%' OR last_name LIKE 'A%'
   ORDER BY last_name;


4. 각 사원의 이름을 표시하고 근무 달 수(입사일로부터 현재까지의 달 수)를 계산하여 
   열 레이블을 MONTHS_WORKED로 지정한다. 
   결과는 정수로 반올림하여 표시하고 근무 달 수를 기준으로 정렬한다.

   SELECT   last_name, ROUND(MONTHS_BETWEEN(SYSDATE, hire_date)) MONTHS_WORKED      
   FROM     employees      
   ORDER BY MONTHS_BETWEEN(SYSDATE, hire_date);


5. 각 사원에 대해 다음 항목을 생성하는 질의를 작성한다.	
   <employee last name> earns <salary> monthly but wants <3 times salary>. 
   열 레이블을 Dream Salaries로 지정한다.

   SELECT   last_name || ' earns ' || TO_CHAR(salary, 'fm$99,999.00')               
            || ' monthly but wants ' || TO_CHAR(salary * 3, 'fm$99,999.00')               
            || '.' "Dream Salaries"      
   FROM     employees;


6. 모든 사원의 이름과 급여를 표시하는 질의를 작성한다. 
   급여는 15자 길이로 왼쪽에 $ 기호가 채워진 형식으로 표기하고 열 레이블을 SALARY로 지정한다.

   SELECT   last_name, LPAD(salary, 15, '$') SALARY     
   FROM     employees;


7. 사원의 이름, 입사일 및 급여 검토일을 표시한다. 급여 검토일은 여섯 달이 경과한 후 
   첫번째 월요일이다. 열 레이블을 REVIEW로 지정하고 날짜는 "Monday, the Thirty-First of July, 2000"과 
   같은 형식으로 표시되도록 지정한다.

   SELECT   last_name, hire_date, TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date, 6),'MONDAY'),
            'fmDay, "the" Ddspth "of" Month, YYYY') REVIEW    
   FROM     employees;


8. 이름, 입사일 및 업무 시작 요일을 표시하고 열 레이블을 DAY로 지정한다. 
   Monday를 시작으로 해서 요일을 기준으로 결과를 정렬한다.

   SELECT   last_name, hire_date, TO_CHAR(hire_date, 'DAY') DAY      
   FROM     employees      
   ORDER BY TO_CHAR(hire_date - 1, 'd');


9. 사원의 이름과 커미션 합계를 표시하는 질의를 작성한다. 커미션을 받지 않는 사원일 경우 
   "No Commission"을 표시한다. 열 레이블은 COMM으로 지정한다.

   SELECT   last_name, NVL(TO_CHAR(commission_pct), 'No Commission') COMM      
   FROM     employees;


10. 사원의 이름을 표시하고 급여 총액을 별표(*)로 나타내는 질의를 작성한다. 
    각 별표는 1,000달러를 나타낸다. 급여를 기준으로 데이터를 내림차순으로 정렬하고 열 레이블을
    EMPLOYEES_AND_THEIR_SALARIES로 지정한다.

    SELECT   rpad(last_name, 8)||' '|| rpad(' ', salary/1000+1, '*') 
             EMPLOYEES_AND_THEIR_SALARIES     
    FROM     employees      
    ORDER BY salary DESC;


11. DECODE 함수를 사용하여 다음 데이터에 따라 JOB_ID 열의 값을 기준으로 
    모든 사원의 등급을 표시하는 질의를 작성한다.

    업무		               등급	
    AD_PRES			A	
    ST_MAN			B	
    IT_PROG			C	
    SA_REP			D	
    ST_CLERK			E	
    None of the above		F	
	
    SELECT job_id, decode (job_id, 'ST_CLERK',  'E',
                                   'SA_REP',    'D',
                                   'IT_PROG',   'C',
                                   'ST_MAN',    'B',
                                   'AD_PRES',   'A',
                                                'F') GRADE
    FROM employees;
 

12. 앞 문제의 명령문을 CASE 구문을 사용하여 재 작성한다.

    SELECT job_id, CASE job_id WHEN 'ST_CLERK' THEN 'E'
                               WHEN 'SA_REP'   THEN 'D'
                               WHEN 'IT_PROG'  THEN 'C'
                               WHEN 'ST_MAN'   THEN 'B'
                               WHEN 'AD_PRES'  THEN 'A'
                               ELSE 'G'  END  GRADE
    FROM employees;


===============================
실습 4. 그룹 함수
===============================

1. 그룹 함수는 여러 행에 적용되어 그룹 당 하나의 결과를 출력한다.

   True


2. 그룹 함수는 계산에 널을 포함한다.

   False. 
   그룹 함수는 널 값을 무시한다. 
   널 값을 포함시키려면 NVL 함수를 사용한다.


3. WHERE 절은 그룹 계산에 행(row)을 포함시키기 전에 행을 제한한다.

   True


4. 모든 사원의 급여 최고액, 최저액, 총액 및 평균액을 표시한다. 
   열 레이블을 각각 Maximum, Minimum, Sum 및 Average로 지정하고 결과를 정수로 반올림한다. 

   SELECT   ROUND(MAX(salary),0) "Maximum", ROUND(MIN(salary),0) "Minimum",
            ROUND(SUM(salary),0) "Sum", ROUND(AVG(salary),0) "Average"      
   FROM     employees;


5. 앞의 질의를 수정하여 각 업무 유형별로 급여 최고액, 최저액, 총액 및 평균액을 표시한다.

   SELECT   job_id, ROUND(MAX(salary),0) "Maximum", ROUND(MIN(salary),0) "Minimum",
            ROUND(SUM(salary),0) "Sum", ROUND(AVG(salary),0) "Average"      
   FROM     employees      
   GROUP BY job_id;


6. 업무가 동일한 사원 수를 표시하는 질의를 작성한다.

   SELECT   job_id, COUNT(*)      
   FROM     employees      
   GROUP BY job_id;


7. 관리자는 나열하지 말고 관리자 수를 확인한다. 
   열 레이블은 Number of Managers로 지정한다.

   SELECT   COUNT(DISTINCT manager_id) "Number of Managers"     
   FROM     employees;


8. 최고 급여와 최저 급여의 차액을 표시하는 질의를 작성하고 열 레이블을 DIFFERENCE로 지정한다.

   SELECT   MAX(salary) - MIN(salary) DIFFERENCE      
   FROM     employees;


9. 관리자 번호 및 해당 관리자에 속한 사원의 최저 급여를 표시한다.
   관리자를 알 수 없는 사원 및 최저 급여가 $6,000 미만인 그룹은 제외시키고 
   결과를 급여에 대한 내림차순으로 정렬한다.

   SELECT   manager_id, MIN(salary)      
   FROM     employees      
   WHERE    manager_id IS NOT NULL      
   GROUP BY manager_id      
   HAVING   MIN(salary) > 6000      
   ORDER BY MIN(salary) DESC;


10. 각 부서에 대해 부서 이름, 위치, 사원 수, 부서 내 모든 사원의 평균 급여를 표시하는 
    질의를 작성하고, 열 레이블을 각각 Name, Location, Number of People 및 Salary로 지정한다. 
    평균 급여는 소수점 둘째 자리로 반올림한다.
      
    SELECT   d.department_name "Name", d.location_id "Location", 
             COUNT(*) "Number of People", ROUND(AVG(salary),2) "Salary"      
    FROM     employees e, departments d      
    WHERE    e.department_id = d.department_id     
    GROUP BY d.department_name, d.location_id;


11. 총 사원 수 및 2005, 2006, 2007, 2008년에 입사한 사원 수를 표시하는 질의를 작성하고 
    적합한 열 머리글을 작성한다.

    SELECT  COUNT(*) total, 
            SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2005, 1, 0)) "2005",
            SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2006, 1, 0)) "2006",
            SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2007, 1, 0)) "2007",
            SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2008, 1, 0)) "2008"      
    FROM    employees;


12. 업무를 표시한 다음 해당 업무에 대해 부서 번호별 급여 및 부서 20, 50, 80 및 90의 
    급여 총액을 각각 표시하는 행렬 질의를 작성하고 각 열에 적합한 머리글을 지정한다.

    SELECT   job_id "Job",
             SUM(DECODE(department_id , 20, salary)) "Dept 20",
             SUM(DECODE(department_id , 50, salary)) "Dept 50",
             SUM(DECODE(department_id , 80, salary)) "Dept 80",
             SUM(DECODE(department_id , 90, salary)) "Dept 90", 
             SUM(salary) "Total"      
    FROM     employees      
    GROUP BY job_id;


===============================
실습 5. 조인
===============================

1. 모든 사원의 이름, 부서 번호, 부서 이름을 표시하는 질의를 작성한다.

   SELECT e.last_name, e.department_id, d.department_name
   FROM employees e, departments d
   WHERE e.department_id = d.department_id;
   
    
2. 부서 80에 속하는 모든 업무의 고유 목록을 작성하고 출력 결과에 부서의 위치를 포함시킨다.

   SELECT DISTINCT job_id, location_id
   FROM employees, departments
   WHERE employees.department_id = departments.department_id
   AND employees.department_id = 80;
   
    
3. 커미션을 받는 모든 사원의 이름, 부서 이름, 위치 ID 및 도시를 표시하는 질의를 작성한다.
       
   SELECT e.last_name, d.department_name, d.location_id, l.city
   FROM employees e, departments d, locations l
   WHERE e.department_id = d.department_id
   AND
   d.location_id = l.location_id
   AND e.commission_pct IS NOT NULL;


4. 이름에 a(소문자)가 포함된 모든 사원의 이름과 부서 이름을 표시하는 질의를 작성한다.
     
   SELECT last_name, department_name
   FROM employees, departments
   WHERE employees.department_id = departments.department_id
   AND last_name LIKE '%a%';
   
   
5. Toronto에서 근무하는 모든 사원의 이름, 업무, 부서 번호 및 부서 이름을 표시하는 질의를 작성한다.

   SELECT e.last_name, e.job_id, e.department_id, 
          d.department_name
   FROM employees e JOIN departments d 
   ON (e.department_id = d.department_id)
   JOIN locations l
   ON (d.location_id = l.location_id)
   WHERE LOWER(l.city) = 'toronto';


6. 사원의 이름 및 사원 번호를 관리자의 이름 및 관리자 번호와 함께 표시하고 각각의 열 레이블을 
   Employee, Emp#, Manager, Mgr#로 지정한다. 

   SELECT w.last_name "Employee", w.employee_id "EMP#", 
          m.last_name "Manager", m.employee_id  "Mgr#"
   FROM employees w join employees m
   ON (w.manager_id = m.employee_id);


7. King을 포함하여 관리자가 없는 모든 사원을 표시하도록 하고 결과를 사원 번호를 기준으로 정렬한다. 

   SELECT w.last_name "Employee", w.employee_id "EMP#", 
          m.last_name "Manager", m.employee_id  "Mgr#"
   FROM employees w LEFT OUTER JOIN employees m
   ON (w.manager_id = m.employee_id);


8. 지정한 사원의 이름, 부서 번호 및 지정한 사원과 동일한 부서에서 근무하는 모든 사원을 표시하도록 
   질의를 작성하고 각 열에 적합한 레이블을 지정한다.

   SELECT e.department_id department, e.last_name employee,
          c.last_name colleague
   FROM   employees e JOIN employees c
   ON     (e.department_id = c.department_id)
   WHERE   e.employee_id <> c.employee_id
   ORDER BY e.department_id, e.last_name, c.last_name;


9. JOB_GRADES 테이블을 생성하고 데이터 입력 후, 
   모든 사원의 이름, 업무, 부서 이름, 급여 및 등급을 표시하는 질의를 작성한다. 

   CREATE TABLE job_grades
   (grade_level VARCHAR2(3), lowest_sal NUMBER, highest_sal NUMBER);

   INSERT INTO job_grades VALUES('A', 1000, 2999);
   INSERT INTO job_grades VALUES('B', 3000, 5999);
   INSERT INTO job_grades VALUES('C', 6000, 9999);
   INSERT INTO job_grades VALUES('D', 10000, 14999);
   INSERT INTO job_grades VALUES('E', 15000, 24999);
   INSERT INTO job_grades VALUES('F', 25000, 40000);
   COMMIT;

   SELECT e.last_name, e.job_id, d.department_name,
          e.salary, j.grade_level
   FROM   employees e, departments d, job_grades j
   WHERE  e.department_id = d.department_id
   AND    e.salary BETWEEN j.lowest_sal AND j.highest_sal;
   
   -- 또는

   SELECT e.last_name, e.job_id, d.department_name,
          e.salary, j.grade_level
   FROM   employees e JOIN departments d
   ON     (e.department_id = d.department_id)
   JOIN   job_grades j
   ON    (e.salary BETWEEN j.lowest_sal AND j.highest_sal);


10. Davies라는 사원보다 늦게 입사한 사원의 이름과 입사일을 표시하는 질의를 작성한다.

    SELECT e.last_name, e.hire_date
    FROM   employees e, employees davies
    WHERE  davies.last_name = 'Davies'
    AND    davies.hire_date < e.hire_date;

    -- 또는

    SELECT e.last_name, e.hire_date
    FROM   employees e JOIN employees davies
    ON     (davies.last_name = 'Davies')
    WHERE  davies.hire_date < e.hire_date;


11. 관리자보다 먼저 입사한 모든 사원의 이름 및 입사일을 관리자의 이름 및 입사일과 함께 표시하고 
    열 레이블을 각각 Employee, Emp Hired, Manager, Mgr Hired로 지정한다.
     
    SELECT w.last_name, w.hire_date, m.last_name, m.hire_date
    FROM   employees w, employees m
    WHERE  w.manager_id = m.employee_id
    AND    w.hire_date <  m.hire_date;

    -- 또는

    SELECT w.last_name, w.hire_date, m.last_name, m.hire_date
    FROM   employees w JOIN employees m
    ON    (w.manager_id = m.employee_id)
    WHERE    w.hire_date <  m.hire_date;


===============================
실습 6. 서브쿼리
===============================

1. Zlotkey와 동일한 부서에 속한 모든 사원의 이름과 입사일을 표시하는 질의를 작성한다. 
   Zlotkey는 제외한다.

   SELECT last_name, hire_date
   FROM   employees
   WHERE  department_id = (SELECT department_id
                           FROM   employees
                           WHERE  last_name = 'Zlotkey')
   AND    last_name <> 'Zlotkey';
       

2. 급여가 평균 급여보다 많은 모든 사원의 사원 번호와 이름을 표시하는 질의를 작성하고 
   결과를 급여에 대해 오름차순으로 정렬한다.

   SELECT employee_id, last_name
   FROM   employees
   WHERE  salary > (SELECT AVG(salary)
                    FROM   employees)
   ORDER BY salary;

 
3. 이름에 u가 포함된 사원과 같은 부서에서 일하는 모든 사원의 사원 번호와 이름을 표시하는
   질의를 작성한다.

    SELECT employee_id, last_name
    FROM   employees
    WHERE  department_id IN (SELECT department_id
                             FROM   employees
                             WHERE  last_name like '%u%');


4. 부서 위치 ID가 1700인 모든 사원의 이름, 부서 번호 및 업무 ID를 표시한다.

   SELECT last_name, department_id, job_id
   FROM   employees
   WHERE  department_id IN (SELECT department_id
                            FROM   departments
                            WHERE  location_id = 1700);


5. King에게 보고하는 모든 사원의 이름과 급여를 표시한다.

   SELECT last_name, salary
   FROM   employees
   WHERE  manager_id = (SELECT employee_id
                        FROM   employees
                        WHERE  last_name = 'King' AND employee_id = 100);


6. Executive 부서의 모든 사원에 대한 부서 번호, 이름 및 업무 ID를 표시한다.

   SELECT department_id, last_name, job_id
   FROM   employees
   WHERE  department_id IN (SELECT department_id
                            FROM   departments
                            WHERE  department_name = 'Executive');


7. 평균 급여보다 많은 급여를 받고 이름에 u가 포함된 사원과 같은 부서에서 근무하는 
   모든 사원의 사원 번호, 이름 및 급여를 표시하는 질의를 작성한다.

    SELECT employee_id, last_name, salary
    FROM   employees
    WHERE  department_id IN (SELECT department_id
                             FROM   employees
                             WHERE  last_name like '%u%')
    AND    salary > (SELECT AVG(salary)
                     FROM   employees);


===============================
실습 7. DML
===============================

1. 다음 문장을 실행하여 실습에 사용할 MY_EMPLOYEE 테이블을 생성한다.

   CREATE TABLE my_employee
   (id  NUMBER(4) CONSTRAINT my_employee_id_nn NOT NULL,
    last_name VARCHAR2(25),
    first_name VARCHAR2(25),
    userid  VARCHAR2(8),
    salary  NUMBER(9,2));


2. MY_EMPLOYEE 테이블의 구조를 표시하여 열 이름을 식별한다.

   DESCRIBE my_employee


3. 다음 예제 데이터의 첫번째 데이터 행(row)을 MY_EMPLOYEE 테이블에 추가한다. 
   INSERT 절에 열을 나열하지 마십시오.

   ID  LAST_NAME  FIRST_NAME  USERID    SALARY
   1   Patel      Ralph       rpatel    895
   2   Dancs      Betty       bdancs    860
   3   Biri       Ben         bbiri     1100
   4   Newman     Chad        cnewman   750
   5   Ropeburn   Audrey      aropebur  1550
	  

   INSERT INTO my_employee      
   VALUES (1, 'Patel', 'Ralph', 'rpatel', 895);


4. 위의 목록에 있는 예제 데이터의 두번째 행을 MY_EMPLOYEE 테이블에 추가한다. 
   이번에는 INSERT 절에 열을 명시적으로 나열한다.

   INSERT INTO my_employee (id, last_name, first_name, userid, salary)
   VALUES (2, 'Dancs', 'Betty', 'bdancs', 860);


5. 테이블에 추가한 항목을 확인한다.

   SELECT   *
   FROM     my_employee;


6. MY_EMPLOYEE 테이블로 insert 문을 작성하여 나머지 행들을 추가한다. 

   INSERT INTO my_employee      
   VALUES (3, 'Biri', 'Ben', 'bbiri', 1100);

   INSERT INTO my_employee      
   VALUES (4, 'Newman', 'Chad', 'cnewman', 750);

   INSERT INTO my_employee      
   VALUES (5, 'Ropeburn', 'Audrey', 'aropebur', 550);

	
7. 테이블에 추가한 항목을 확인한다.

   SELECT   *
   FROM my_employee;


8. 추가한 데이터를 영구히 저장한다.

   COMMIT;


9. 사원 3의 성을 Drexler로 변경한다.

   UPDATE  my_employee     
   SET     last_name = 'Drexler'      
   WHERE   id = 3;


10. 급여가 900 미만인 모든 사원의 급여를 1000으로 변경한다.

    UPDATE  my_employee      
    SET     salary = 1000      
    WHERE   salary < 900;


11. 테이블의 변경 내용을 확인한다.

    SELECT  last_name, salary      
    FROM    my_employee;


12. MY_EMPLOYEE 테이블에서 Betty Dancs를 삭제한다.

    DELETE FROM  my_employee      
    WHERE last_name = 'Dancs';


13. 테이블의 변경 내용을 확인한다.

    SELECT  *      
    FROM    my_employee;


14. 보류 중인 변경 내용을 모두 커밋한다.

    COMMIT;


===============================
실습 8. 테이블/인덱스 생성 및 관리
===============================

1. 다음 정보를 기반으로 DEPT 테이블을 생성한다. 테이블이 생성되었는지 확인한다.

   열이름  데이터유형  길이
   ID      NUMBER      7
   NAME    VARCHAR2    25
  

   CREATE TABLE dept
   (id NUMBER(7),
    name VARCHAR2(25));

   DESCRIBE dept


2. DEPARTMENT 테이블의 데이터를 DEPT 테이블에 추가한다. 필요한 열만 추가한다.

   INSERT INTO dept      
   SELECT  department_id, department_name      
   FROM    departments;


3. 다음 정보를 기반으로 EMP 테이블을 생성한다. 테이블이 생성되었는지 확인한다.

   열이름      데이터유형  길이
   ID          NUMBER      7
   LAST_NAME   VARCHAR2    25
   FIRST_NAME  VARCHAR2    25
   DEPT_ID     NUMBER      7


   CREATE TABLE  emp
   (id           NUMBER(7),
    last_name    VARCHAR2(25),
    first_name   VARCHAR2(25),
    dept_id      NUMBER(7));

   DESCRIBE emp


4. EMP 테이블 last_name 열의 길이를 50으로 수정한 후 수정 내용을 확인한다.

   ALTER TABLE emp
   MODIFY (last_name   VARCHAR2(50));

   DESCRIBE emp


5. DEPT 및 EMP 테이블이 모두 데이터 딕셔너리에 저장되었는지 확인한다(힌트: USER_TABLES).

   SELECT   table_name
   FROM     user_tables
   WHERE    table_name IN ('DEPT', 'EMP');


6. EMPLOYEES 테이블 구조를 기반으로 EMPLOYEES2 테이블을 생성한다. 
   EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY 및 DEPARTMENT_ID 열만 포함시키고, 
   새 테이블의 열 이름을 각각 ID, FIRST_NAME, LAST_NAME, SALARY 및 DEPT_ID로 지정한다.

   CREATE TABLE employees2 
   AS      
   SELECT  employee_id id, first_name, last_name, salary, department_id dept_id      
   FROM    employees;


7. EMP 테이블을 삭제한다.

   DROP TABLE emp;


8. EMPLOYEES2 테이블의 이름을 EMP로 변경한다.

   RENAME employees2 TO emp;


9. DEPT 및 EMP 테이블 정의에 테이블을 설명하는 주석을 추가한 후 데이터 딕셔너리에서 
   추가한 항목을 확인한다.

   COMMENT ON TABLE emp IS 'Employee Information';

   COMMENT ON TABLE dept IS 'Department Information';

   SELECT  *
   FROM    user_tab_comments
   WHERE   table_name = 'DEPT'
   OR      table_name = 'EMP';


10. EMP 테이블에서 FIRST_NAME 열을 삭제한 후 테이블 설명을 참조하여 수정 내용을 확인한다.

    ALTER TABLE emp
    DROP COLUMN FIRST_NAME;

    DESCRIBE emp


11. EMP 테이블의 외래 키 열(DEPT_ID)에 대해 비고유 인덱스를 생성한다.

    CREATE INDEX emp_dept_id_idx ON emp (dept_id);


12. 데이터 딕셔너리에 있는 EMP 테이블의 인덱스 및 고유성을 표시한다.

    SELECT   index_name, table_name, uniqueness 
    FROM     user_indexes 
    WHERE    table_name = 'EMP'; 


===============================
실습 9. 제약조건
===============================

1. 제약조건을 테스트할 MASTER, SLAVE 테이블을 생성한다.

   CREATE TABLE master
   (id NUMBER(3) CONSTRAINT master_id_pk PRIMARY KEY,
    name VARCHAR2(15) CONSTRAINT master_name_nn NOT NULL,
    phone VARCHAR2(13) CONSTRAINT master_phone_uk UNIQUE,
    salary NUMBER(4) CONSTRAINT master_salary_ck CHECK(salary > 1000));
 
    DESC master
 
    CREATE TABLE slave
    (s_id NUMBER(3) CONSTRAINT slave_s_id_pk PRIMARY KEY,
     s_location VARCHAR2(20) CONSTRAINT slave_s_location_uk UNIQUE,
     s_grade NUMBER(1) CONSTRAINT slave_s_grade_ck CHECK(s_grade IN(1,2,3,4)),
     s_master_id NUMBER(3) CONSTRAINT slave_s_master_id_fk REFERENCES master (id));

    DESC slave
 

2. MASTER와 SLAVE 테이블에 데이터를 입력하여 제약조건을 테스트한다.
 
    INSERT INTO master
    VALUES(111, 'chan_ho', '018-411-2178', 5000);
 
    -- Error입니다. 무슨 Error일까요?
    INSERT INTO master
    VALUES(111, 'in_ho', '017-411-2178', 4000);
 
    다시 아래와 같이 입력해 보세요.
    INSERT INTO master
    VALUES(222, 'in_ho', '017-411-2178', 4000);
 
    -- Error입니다. 무슨 Error일까요?
    INSERT INTO master
    VALUES(333, NULL, '019-411-2178', 8000);
 
    다시 아래와 같이 입력해 보세요.
    INSERT INTO master
    VALUES(333, 'jung_ho', '019-411-2178', 8000);
 
    -- Error입니다. 무슨 Error일까요?
    INSERT INTO master
    VALUES(444, 'ki_ho', '018-411-2178', 3000);
 
    다시 아래와 같이 입력해 보세요.
    INSERT INTO master
    VALUES(444, 'ki_ho', '011-411-2178', 3000);
 
    -- Error입니다. 무슨 Error일까요?
    INSERT INTO MASTER
    VALUES(555, 'young_ho', '016-411-2178', 900);
 
    다시 아래와 같이 입력해 보세요.
    INSERT INTO master
    VALUES(555, 'young_ho', '016-411-2178', 6000);
 
    SELECT * FROM master;
 
    INSERT INTO slave
    VALUES(111, 'tae_jeon', 1, 222);

    -- Error입니다. 무슨 Error일까요?
    INSERT INTO slave
    VALUES(222, 'gwang_ju', 2, 999);
 
    다시 아래와 같이 입력해 보세요.
    INSERT INTO slave
    VALUES(444, 'gwang_ju', 2, 222);
 
    SELECT * FROM slave;


3. USER_CONSTRAINTS 뷰를 질의하여 제약 조건이 추가되었는지 확인하고 
   제약 조건의 유형 및 이름을 적어둔다.

   SELECT   constraint_name, constraint_type      
   FROM     user_constraints      
   WHERE    table_name IN ('MASTER','SLAVE');


4. USER_OBJECTS 데이터 딕셔너리 뷰에서 MASTER 및 SLAVE 테이블의 객체 이름 및 유형을 표시한다. 
   새 테이블 및 새 인덱스가 생성된 것을 볼 수 있다.

   COL object_name FOR A20

   SELECT   object_name, object_type      
   FROM     user_objects      
   WHERE    object_name LIKE 'MASTER%'      
   OR       object_name LIKE 'SLAVE%';


===============================
실습 10. 뷰 생성
===============================

1. EMPLOYEES 테이블에서 사원 번호, 사원 이름 및 부서 번호를 기반으로 하는 EMPLOYEES_VU라는 
   뷰를 생성한다. 사원 이름의 머리글을 EMPLOYEE로 변경한다.

   CREATE OR REPLACE VIEW employees_vu 
   AS
   SELECT employee_id, last_name employee, department_id
   FROM employees;


2. EMPLOYEES_VU 뷰의 내용을 표시한다.

   SELECT   *      
   FROM     employees_vu;


3. USER_VIEWS 데이터 딕셔너리 뷰에서 뷰 이름 및 텍스트를 선택한다.
   참고: LONG 열의 내용을 더 많이 보려면 SQL*Plus 명령인 SET LONG n을 사용한다. 
         여기서 n은 보려는 LONG 열의 문자 수를 나타내는 값이다.

   SET LONG 600

   SELECT   view_name, text     
   FROM     user_views;


4. EMPLOYEES_VU 뷰를 사용하여 모든 사원의 이름 및 부서 번호를 표시하는 질의를 작성한다.

   SELECT   employee, department_id      
   FROM     employees_vu;


5. 모든 사원의 이름, 부서 이름, 급여 및 급여 등급을 기반으로 하는 SALARY_VU라는 뷰를 생성한다.             
   EMPLOYEES, DEPARTMENTS 및 JOB_GRADES 테이블을 사용하고 열 레이블을 
   각각 Employee, Department, Salary 및 Grade로 지정한다.
   
   CREATE OR REPLACE VIEW salary_vu
   AS
   SELECT e.last_name "Employee",
          d.department_name "Department",
          e.salary "Salary",
          j.grade_level "Grades"
   FROM   employees e, departments d, job_grades j
   WHERE  e.department_id = d.department_id
   AND    e.salary BETWEEN j.lowest_sal and j.highest_sal;


========================================
실습 11. 시퀀스, 동의어
========================================

1. DEPT 테이블의 기본 키 열에 사용할 시퀀스를 생성한다. 
   시퀀스 값은 300부터 시작하여 10씩 증가하며 최대 1000까지 가능하다. 
   시퀀스 이름은 DEPT_ID_SEQ로 지정한다.

   CREATE SEQUENCE dept_id_seq      
   START WITH 300      
   INCREMENT BY 10      
   MAXVALUE 1000;


2. 시퀀스 이름, 최대값, 증가분, 마지막 번호와 같은 시퀀스 정보를 표시하는 질의를 작성한다.

   SELECT   sequence_name, max_value, increment_by, last_number
   FROM     user_sequences;


3. DEPT 테이블에 두 행(row)을 삽입하는 문장을 작성한다. ID 열에 대해서는 이전에 생성한 
   시퀀스를 사용한다. Education 및 Administration이라는 두 개의 부서를 추가하고 결과를 
   확인한 후 스크립트의 명령을 실행한다.

   INSERT INTO dept
   VALUES (dept_id_seq.nextval, 'Education');

   INSERT INTO dept
   VALUES (dept_id_seq.nextval, 'Administration');


4. DEPARTMENTS 테이블의 간략한 이름인 동의어 D를 생성한다.

   CREATE SYNONYM d
   FOR departments;


5. 동의어 D를 사용하여 테이블의 구조와 데이터를 조회한다.

   DESC d

   SELECT * FROM d;


6. 동의어 d를 삭제한다.

   DROP SYNONYM d;


===============================
실습 12. 사용자 액세스 제어
===============================

1. 사용자가 Oracle Server에 로그인하기 위해 필요한 권한은 무엇인가? 
   시스템 권한과 객체 권한 중 어느 것인가?

   CREATE SESSION 시스템 권한


2. 테이블을 생성할 때 필요한 권한은 무엇인가?

   CREATE TABLE 권한


3. 생성한 테이블에 대한 권한을 다른 사용자에게 부여할 수 있는 사용자는 누구인가?

   생성자 및 생성자가 WITH GRANT OPTION을 사용하여 해당 권한을 부여한 사람


4. DBA가 동일한 시스템 권한이 필요한 사용자를 여러 명 생성할 때 
   간편하게 작업할 수 있는 방법은 무엇인가?

   시스템 권한을 포함하는 롤을 생성하여 사용자에게 부여한다.	


5. 암호를 변경할 때 사용하는 명령은 무엇인가?

   ALTER USER 문


6. DBA 계정으로 사용자 이름은 TOMAS 암호는 oracle로 생성하고 CONNECT, RESOURCE 롤과 
   CREATE SYNONYM 권한을 부여한다.

   CONNECT system/oracle

   CREATE USER TOMAS IDENTIFIED BY oracle;

   GRANT CONNECT, RESOURCE, CREATE SYNONYM TO TOMAS;


7. HR 사용자의 DEPARTMENTS 테이블에 대한 SELECT 권한을 TOMAS 사용자에게 부여한다.

   GRANT SELECT ON hr.departments TO TOMAS;


8. TOMAS 사용자로 접속하여 HR 사용자의 DEPARTMENTS 테이블에 있는 모든 행(row)을 질의한다.

   CONNECT TOMAS/oracle

   SELECT  *
   FROM    hr.departments;


9. TOMAS 사용자로 접속하여 HR 사용자의 DEPARTMENTS 테이블에 대한 동의어 DEP를 생성한다.

   CONNECT TOMAS/oracle

   CREATE SYNONYM DEP 
   FOR hr.departments;


10. 앞에서 만든 동의어를 사용하여 HR 사용자의 DEPARTMENTS 테이블에 포함된 모든 행(row)을 질의한다.

    SELECT  *
    FROM    DEP;


11. TOMAS 사용자 자신이 소유한 테이블에 대한 정보를 표시하도록 USER_TABLES 데이터 딕셔너리를 질의한다.

    SELECT  table_name      
    FROM    user_tables;


12. TOMAS 사용자가 액세스할 수 있는 모든 테이블에 대한 정보를 표시하도록 
    ALL_TABLES 데이터 딕셔너리 뷰를 질의한다.

    SELECT  table_name, owner     
    FROM    all_tables;     


13. TOMAS 사용자에게 부여했던 HR 사용자의 DEPARTMENTS 테이블에 대한 SELECT 권한을 취소한다.

    CONNECT system/oracle
    -- 또는 
    CONNECT hr/hr

    REVOKE select       
    ON     hr.departments       
    FROM   TOMAS;


===============================
실습 13. PL/SQL 소개
===============================

1. 다음 PL/SQL 블록 중 성공적으로 실행되는 블록은 무엇인가? d

a. BEGIN
   END;

b. DECLARE
      amount INTEGER(10);
   END;

c. DECLARE
   BEGIN
   END;

d. DECLARE
     amount INTEGER(10);
   BEGIN
   DBMS_OUTPUT.PUT_LINE(amount);
   END;

- a의 블록은 실행 섹션에 명령문이 없기 때문에 실행되지 않는다.
- b의 블록에는 BEGIN 키워드로 시작하는 필수 실행 섹션이 없다.
- c의 블록에는 필요한 항목이 모두 있지만 실행 섹션에 명령문이 없다.


2. "Hello World"를 출력하는 간단한 익명 블록을 생성하여 실행한다. 

SET SERVEROUTPUT ON

BEGIN
  DBMS_OUTPUT.PUT_LINE(' Hello World ');
END;
/


===============================
실습 14. PL/SQL 변수 선언
===============================

1. 유효한 식별자와 부적합한 식별자를 구분한다.

a. today 유효

b. last_name 유효

c. today's_date 부적합 -- " ' " 문자는 허용되지 않는다.

d. Number_of_days_in_February_this_year 부적합 -- 너무 길다.

e. Isleap$year 유효

f. #number 부적합 -- "#"로 시작할 수 없다.

g. NUMBER# 유효

h. number1to7 유효


2. 다음 변수 선언 및 초기화가 유효한지 부적합한지 식별한다.

a. number_of_copies PLS_INTEGER; 유효

b. PRINTER_NAME constant VARCHAR2(10); 부적합

c. deliver_to VARCHAR2(10):=Johnson; 부적합

d. by_when DATE:= SYSDATE+1; 유효

상수 변수는 선언 시에 초기화되어야 하기 때문에 b의 선언은 유효하지 않다.
문자열 리터럴은 작은 따옴표로 묶어야 하기 때문에 c의 선언은 유효하지 않다.


3. 다음 익명 블록을 검토하고 올바른 문장을 선택한다. a

DECLARE
  v_fname VARCHAR2(20);
  v_lname VARCHAR2(15) DEFAULT 'king';
BEGIN
  DBMS_OUTPUT.PUT_LINE(v_fname ||' ' ||v_lname);
END;

a. 블록이 성공적으로 실행되고 "king"이 출력된다.
b. fname 변수가 초기화하지 않고 사용되었기 때문에 오류가 발생한다.
c. 블록이 성공적으로 실행되고 "null king"이 출력된다.
d. VARCHAR2 유형의 변수를 초기화하는 데 DEFAULT 키워드를 사용할 수 없기 때문에 오류가 발생한다.
e. v_fname 변수를 선언하지 않았기 때문에 오류가 발생한다.


4. 익명 블록을 생성한다. SQL Plus 에서 연습 13의 2번 문제에서 생성한 스크립트를 다음 지침에 따라 수정한다.

1) 이 PL/SQL 블록에 선언 섹션을 추가한다. 선언 섹션에서 다음 변수를 선언한다.

- DATE 유형의 today 변수. today 를 SYSDATE 로 초기화한다.
DECLARE
  v_today DATE:=SYSDATE;

- today 유형의 tomorrow 변수. %TYPE 속성을 사용하여 이 변수를 선언한다.
  v_tomorrow v_today%TYPE;

2) 실행 섹션에서 내일 날짜를 계산하는 표현식(today 값에 1 추가)을 사용하여 tomorrow 변수를 초기화한다. 
   "Hello World"를 출력한 후 today 와 tomorrow 의 값을 출력한다.

BEGIN
  v_tomorrow:=v_today +1;
  DBMS_OUTPUT.PUT_LINE(' Hello World ');
  DBMS_OUTPUT.PUT_LINE('TODAY IS : '|| v_today);
  DBMS_OUTPUT.PUT_LINE('TOMORROW IS : ' || v_tomorrow);
END;

c. 스크립트를 실행한다. 예제의 출력 결과는 다음과 같다.

Hello World
TODAY IS : 18-MAR-14
TOMORROW IS : 18-MAR-14

PL/SQL procedure successfully completed.


5. 4번 문제 스크립트를 수정한다.

1) 두 개의 바인드 변수를 생성하는 코드를 추가한다.

NUMBER 유형의 바인드 변수 basic_percent 및 pf_percent 를 생성한다.

VARIABLE b_basic_percent NUMBER
VARIABLE b_pf_percent NUMBER

2) PL/SQL 블록의 실행 섹션에서 basic_percent 와 pf_percent 에 각각 값 45 와 12 를 할당한다.

  :b_basic_percent:=45;
  :b_pf_percent:=12;

3) "/"로 PL/SQL 블록을 종료하고 PRINT 명령을 사용하여 바인드 변수 값을 출력한다.

/

PRINT b_basic_percent
PRINT b_pf_percent
또는
PRINT


4) 스크립트를 실행한다. 예제의 출력 결과는 다음과 같다.

Hello World
TODAY IS : 18-MAR-14
TOMORROW IS : 18-MAR-14

PL/SQL procedure successfully completed.


B_BASIC_PERCENT
---------------
             45


B_PF_PERCENT
------------
          12


===============================
실습 15. 실행문 작성
===============================

DECLARE
  v_weight NUMBER(3) := 600;
  v_message VARCHAR2(255) := 'Product 10012';
BEGIN
  DECLARE
    v_weight NUMBER(3) := 1;
    v_message VARCHAR2(255) := 'Product 11001';
    v_new_locn VARCHAR2(50) := 'Europe';
  BEGIN
    v_weight := v_weight + 1;
    v_new_locn := 'Western ' || v_new_locn;
-- 1번 위치
  END;
  v_weight := v_weight + 1;
  v_message := v_message || ' is in stock';
  v_new_locn := 'Western ' || v_new_locn;
-- 2번 위치
END;
/

1. 앞의 PL/SQL 블록을 검토하여 범위 지정 규칙에 따라 다음 각 변수의 데이터 유형 및 값을 판별한다.

1) 1 위치에서의 v_weight 값 : 2 데이터 유형은 NUMBER

2) 1 위치에서의 v_new_locn 값 : Western Europe 데이터 유형은 VARCHAR2

3) 2 위치에서의 v_weight 값 : 601 데이터 유형은 NUMBER

4) 2 위치에서의 v_message 값 : Product 10012 is in stock. 데이터 유형은 VARCHAR2

5) 2 위치에서의 v_new_locn 값 : v_new_locn 은 하위 블록 외부에서 볼 수 없기 때문에 잘못된 구문이다.


DECLARE
  v_customer VARCHAR2(50) := 'Womansport';
  v_credit_rating VARCHAR2(50) := 'EXCELLENT';
BEGIN
  DECLARE
    v_customer NUMBER(7) := 201;
    v_name VARCHAR2(25) := 'Unisports';
  BEGIN
    v_credit_rating :='GOOD';
    ...
  END;
  ...
END;

2. 앞의 PL/SQL 블록에서 다음 각 경우에 해당하는 값 및 데이터 유형을 판별한다.

1) 중첩된 블록의 v_customer 값 : 201 데이터 유형은 NUMBER

2) 중첩된 블록의 v_name 값 : Unisports 데이터 유형은 VARCHAR2

3) 중첩된 블록의 v_credit_rating 값 : GOOD 데이터 유형은 VARCHAR2

4) 기본 블록의 v_customer 값 : Womansport 데이터 유형은 VARCHAR2

5) 기본 블록의 v_name 값 : v_name 은 기본 블록에서 볼 수 없으며 오류 메시지가 표시된다.

6) 기본 블록의 v_credit_rating 값 : GOOD 데이터 유형은 VARCHAR2


3. 익명 블록을 생성한다. SQL Plus에서 실습 14의 5번 문제에서 생성한 스크립트를 다음 지침에 따라 수정한다.

1) 단일 행 주석 구문을 사용하여 바인드 변수를 생성하는 행을 주석 처리한다.

-- VARIABLE b_basic_percent NUMBER
-- VARIABLE b_pf_percent NUMBER

2) 실행 섹션에서 다중 행 주석을 사용하여 바인드 변수에 값을 할당하는 행을 주석 처리한다.

/*:b_basic_percent:=45;
:b_pf_percent:=12;*/

3) 데이터 유형이 VARCHAR2이고 크기가 15인 fname 및 
   데이터 유형이 NUMBER이고 크기가 10인 emp_sal 이라는 변수를 선언한다.

DECLARE
  v_basic_percent NUMBER:=45;
  v_pf_percent NUMBER:=12;
  v_fname VARCHAR2(15);
  v_emp_sal NUMBER(10);

4) 다음 SQL 문을 실행 섹션에 포함시킨다.

SELECT first_name, salary INTO v_fname, v_emp_sal
FROM employees WHERE employee_id=110;

5) "Hello World"를 출력하는 행을 "Hello"와 이름을 출력하도록 변경한다.
   날짜를 표시하고 바인드 변수를 출력하는 행을 주석 처리한다.

DBMS_OUTPUT.PUT_LINE(' Hello '|| v_fname);

6) 기업 연금(PF)에 대한 사원의 부담금을 계산한다.
   PF 는 기본 급여의 12%이며 기본 급여는 급여의 45%이다.
   계산할 때는 바인드 변수를 사용한다. 표현식을 하나만 사용하여 PF 를 계산한다.
   사원의 급여 및 PF 부담금을 출력한다.

DBMS_OUTPUT.PUT_LINE('YOUR SALARY IS : '||v_emp_sal);
DBMS_OUTPUT.PUT_LINE('YOUR CONTRIBUTION TOWARDS PF:
'||v_emp_sal*v_basic_percent/100*v_pf_percent/100);
END;

7) 스크립트를 실행한다. 예제의 출력 결과는 다음과 같다.

Hello John
YOUR SALARY IS : 8200
YOUR CONTRIBUTION TOWARDS PF:
442.8

PL/SQL procedure successfully completed.


===============================
실습 16. ORACLE 서버와 상호 작용
===============================

1. departments 테이블에서 최대 부서 ID 를 선택하여 v_max_deptno 변수에 저장하는 PL/SQL 블록을 생성한다. 최대 부서 ID 를 표시한다.

1) 선언 섹션에서 NUMBER 유형의 v_max_deptno 변수를 선언한다.

DECLARE
  v_max_deptno NUMBER;

2) BEGIN 키워드로 실행 섹션을 시작하고 departments 테이블에서 최대 department_id 를 검색하는 SELECT 문을 포함시킨다.

BEGIN
  SELECT MAX(department_id) INTO v_max_deptno 
  FROM departments;

3) v_max_deptno를 표시하고 실행 블록을 종료한다.

  DBMS_OUTPUT.PUT_LINE('The maximum department_id is : ' ||
                        v_max_deptno);
END;

4) 스크립트를 실행한다. 예제의 출력 결과는 다음과 같다.

The maximum department_id is : 270

PL/SQL procedure successfully completed.


2. 연습 1 에서 생성한 PL/SQL 블록을 departments 테이블에 새 부서를 삽입하도록 수정한다.

1) 다음 두 변수를 선언한다.
   departments.department_name 유형의 v_dept_name 
   NUMBER 유형의 v_dept_id 선언 섹션에서 v_dept_name 에 'Education'을 할당한다.

  v_dept_name departments.department_name%TYPE:= 'Education';
  v_dept_id NUMBER;

2) 앞에서 이미 departments 테이블에서 현재 최대 부서 번호를 검색했다. 
   이 부서 번호에 10 을 더하여 해당 결과를 dept_id 에 할당한다.

  v_dept_id := 10 + v_max_deptno;

3) departments 테이블의 department_name, department_id 및 location_id 열에 데이터를 삽입하는 INSERT 문을 포함시킨다.
   dept_name과 dept_id의 값을 각각 department_name과 department_id에 사용하고 NULL을 location_id에 사용한다.

  INSERT INTO departments (department_id, department_name,location_id)
  VALUES (v_dept_id,v_dept_name, NULL);

4) SQL 속성 SQL%ROWCOUNT를 사용하여 적용되는 행 수를 표시한다.

  DBMS_OUTPUT.PUT_LINE (' SQL%ROWCOUNT gives ' || SQL%ROWCOUNT);

5) SELECT 문을 실행하여 새 부서가 삽입되었는지 확인한다. "/"로 PL/SQL 블록을 종료하고 스크립트에 SELECT 문을 포함시킨다.

/

SELECT * FROM departments WHERE department_id= 280;

6) 스크립트를 실행한다. 예제의 출력 결과는 다음과 같다.

The maximum department_id is : 270
SQL%ROWCOUNT gives 1

PL/SQL procedure successfully completed.

DEPARTMENT_ID DEPARTMENT_NAME                MANAGER_ID LOCATION_ID
------------- ------------------------------ ---------- -----------
          280 Education


3. 연습 문제 2에서 location_id 를 NULL로 설정했다. 
   새 부서의 location_id를 3000으로 갱신하는 PL/SQL 블록을 생성한다. 

1) BEGIN 키워드로 실행 블록을 시작한다. 
   새 부서(dept_id =280)의 location_id를 3000으로 설정하도록 UPDATE 문을 포함시킨다.

BEGIN
  UPDATE departments SET location_id=3000 WHERE department_id=280;

2) END 키워드로 실행 블록을 종료한다. "/"로 PL/SQL 블록을 실행하고 갱신한 부서를 표시한다.

END;
/

SELECT * FROM departments WHERE department_id=280;

3) 추가한 부서를 삭제한다.

  DELETE FROM departments WHERE department_id=280;
  COMMIT;


===============================
실습 17. 제어 구조 작성
===============================

1. 다음의 문장을 사용하여 messages 테이블을 생성하고, messages 테이블에 숫자를 삽입하는 PL/SQL 블록을 작성한다.

CREATE TABLE messages (results VARCHAR2(80));

1) 1 에서 10 까지의 숫자를 삽입한다(6, 8 제외).
   블록 종료 전에 커밋한다.

BEGIN
  FOR i in 1..10 LOOP
    IF i = 6 or i = 8 THEN
      null;
    ELSE
      INSERT INTO messages(results)
      VALUES (i);
    END IF;
  END LOOP;
  COMMIT;
END;
/

2) SELECT 문을 실행하여 PL/SQL 블록이 작동하는지 확인한다.

SELECT * FROM messages;

출력 결과는 다음과 같아야 한다.

RESULTS
--------------------------------------------------------------------------------
1
2
3
4
5
7
9
10

8 rows selected.


2. 다음 문장을 실행하여 employees 테이블의 복제본인 emp 테이블을 생성한다. 
   그리고 데이터 유형은 VARCHAR2이고 크기는 50인 새 열 stars를 추가하도록 emp 테이블을 변경한다.
   사원의 급여에 대해 $1000 단위마다 stars 열에 별표를 삽입하는 PL/SQL 블록을 생성한다.

CREATE TABLE emp AS SELECT * FROM employees;

ALTER TABLE emp ADD stars VARCHAR2(50);

1) 블록의 선언 섹션에서 emp.employee_id 유형의 v_empno 변수를 선언하고 176으로 초기화한다. 
   emp.stars 유형의 v_asterisk 변수를 선언하고 NULL로 초기화한다. 
   emp.salary 유형의 sal 변수를 생성한다.

DECLARE
  v_empno emp.employee_id%TYPE := 176;
  v_asterisk emp.stars%TYPE := NULL;
  v_sal emp.salary%TYPE;

2) 실행 섹션에서 사원의 급여에 대해 $1,000 단위마다 문자열에 별표(*)를 추가하는 논리를 작성한다. 
   예를 들어, 사원의 급여가 $8,000이면 별표 문자열에는 여덟 개의 별표가 있어야 한다. 
   급여가 $12,500이면 별표 문자열에는 13 개의 별표가 있어야 한다.

  SELECT NVL(ROUND(salary/1000), 0) INTO v_sal
  FROM emp WHERE employee_id = v_empno;
  FOR i IN 1..v_sal
  LOOP
    v_asterisk := v_asterisk ||'*';
  END LOOP;

3) 해당 사원의 stars 열을 별표 문자열로 갱신한다. 블록 종료 전에 커밋한다.

  UPDATE emp SET stars = v_asterisk
  WHERE employee_id = v_empno;
  COMMIT;

4) emp 테이블의 행을 출력하여 PL/SQL 블록이 성공적으로 실행되었는지 확인한다.

SELECT employee_id,salary, stars
FROM emp WHERE employee_id =176;

5) 출력 결과는 다음과 같다.

EMPLOYEE_ID     SALARY STARS
----------- ---------- -------------------
        176       8600 *********


===============================
실습 18. 조합 데이터 유형
===============================

1. 제공된 국가에 대한 정보를 출력하는 PL/SQL 블록을 작성한다.

1) countries 테이블의 구조에 맞게 PL/SQL 레코드를 선언한다.
   v_countryid 변수를 선언한다. v_countryid 에 CA 를 할당한다.

DECLARE
  v_countryid varchar2(20):= 'CA';

2) 선언 섹션에서 %ROWTYPE 속성을 사용하여 countries 유형의 v_country_record 변수를 선언한다.

  v_country_record countries%ROWTYPE;

3) 실행 섹션에서 countryid 를 사용하여 countries 테이블의 모든 정보를 가져온다. 
   선택한 국가의 정보를 표시한다. 

BEGIN
  SELECT *
  INTO v_country_record
  FROM countries
  WHERE country_id = UPPER(v_countryid);
  DBMS_OUTPUT.PUT_LINE ('Country Id: ' ||
  v_country_record.country_id ||
  ' Country Name: ' || v_country_record.country_name
  || ' Region: ' || v_country_record.region_id);
END;

4) 예제의 출력 결과는 다음과 같다.

Country Id: CA Country Name: Canada Region: 2

PL/SQL procedure successfully completed.

5) ID가 DE, UK 및 US인 국가에 대해 PL/SQL 블록을 실행하여 테스트할 수도 있다.


2. INDEX BY 테이블과 통합하여 departments 테이블에서 일부 부서 이름을 검색하여 
   각 부서 이름을 화면에 출력하는 PL/SQL 블록을 생성한다.

1) departments.department_name 유형의 INDEX BY 테이블 dept_table_type 을 선언한다. 
   dept_table_type 유형의 my_dept_table 변수를 선언하여 부서 이름을 임시로 저장한다.

DECLARE
  TYPE dept_table_type is table of departments.department_name%TYPE
       INDEX BY PLS_INTEGER;
  my_dept_table dept_table_type;

2) NUMBER 유형의 두 변수 f_loop_count 및 v_deptno를 선언한다.
   f_loop_count에 10을 할당하고 v_deptno에 0을 할당한다.

  f_loop_count NUMBER (2):=10;
  v_deptno NUMBER (4):=0;

3) 루프를 사용하여 10개의 부서 이름을 검색하고 INDEX BY 테이블에 이름을 저장한다. 
   department_id를 10에서 시작한다. 루프가 반복할 때마다 v_deptno 를 10씩 증가시킨다.
   다음 테이블은 department_name을 검색하여 INDEX BY 테이블에 저장한 department_id를 보여준다.

BEGIN
  FOR i IN 1..f_loop_count
  LOOP
    v_deptno:=v_deptno+10;
  SELECT department_name
  INTO my_dept_table(i)
  FROM departments
  WHERE department_id = v_deptno;
END LOOP;

4) 다른 루프를 사용하여 INDEX BY 테이블에서 부서 이름을 검색한 다음 정보를 출력한다.
  FOR i IN 1..f_loop_count
  LOOP
    DBMS_OUTPUT.PUT_LINE (my_dept_table(i));
  END LOOP;
END;

5) 스크립트를 실행한다. 출력 결과는 다음과 같다.

Administration
Marketing
Purchasing
Human Resources
Shipping
IT
Public Relations
Sales
Executive
Finance

PL/SQL procedure successfully completed.


3. departments 테이블에서 각 부서 정보를 모두 검색하여 출력하도록 2 번 문제에서 생성한 블록을 수정한다. 레코드의 INDEX BY 테이블을 사용한다.

1) INDEX BY 테이블은 departments.department_name 유형으로 선언된 상태이다. 
   부서의 번호, 이름 및 위치를 임시로 저장하도록 INDEX BY 테이블의 선언을 수정한다.  
   %ROWTYPE 속성을 사용한다.

DECLARE
  TYPE dept_table_type is table of departments%ROWTYPE
      INDEX BY PLS_INTEGER;
  my_dept_table dept_table_type;
  f_loop_count NUMBER (2):=10;
  v_deptno NUMBER (4):=0;

2) departments 테이블에서 현재 있는 부서 정보를 모두 검색하여 INDEX BY 테이블에 저장하도록 SELECT 문을 수정한다.

BEGIN
  FOR i IN 1..f_loop_count
  LOOP
    v_deptno := v_deptno + 10;
  SELECT *
  INTO my_dept_table(i)
  FROM departments
  WHERE department_id = v_deptno;
END LOOP;

3) 다른 루프를 사용하여 INDEX BY 테이블에서 부서 정보를 검색한 다음 정보를 출력한다. 
   예제의 출력 결과는 다음과 같다.

  FOR i IN 1..f_loop_count
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Department Number: ' ||
    my_dept_table(i).department_id
    || ' Department Name: ' || my_dept_table(i).department_name
    || ' Manager Id: '|| my_dept_table(i).manager_id
    || ' Location Id: ' || my_dept_table(i).location_id);
  END LOOP;
END;

Department Number: 10 Department Name: Administration Manager Id: 200 Location
Id: 1700
Department Number: 20 Department Name: Marketing Manager Id: 201 Location Id:
1800
Department Number: 30 Department Name: Purchasing Manager Id: 114 Location Id:
1700
Department Number: 40 Department Name: Human Resources Manager Id: 203 Location
Id: 2400
Department Number: 50 Department Name: Shipping Manager Id: 121 Location Id:
1500
Department Number: 60 Department Name: IT Manager Id: 103 Location Id: 1400
Department Number: 70 Department Name: Public Relations Manager Id: 204 Location
Id: 2700
Department Number: 80 Department Name: Sales Manager Id: 145 Location Id: 2500
Department Number: 90 Department Name: Executive Manager Id: 100 Location Id:
1700
Department Number: 100 Department Name: Finance Manager Id: 108 Location Id:
1700

PL/SQL procedure successfully completed.


===============================
실습 19. 명시적 커서 사용
===============================

1. 상위 n 번째까지의 고액 급여를 판별하는 PL/SQL 블록을 생성한다.

1) 사원의 급여를 저장하기 위해 다음 문장을 실행하여 새 테이블 top_salaries를 생성한다.

CREATE TABLE top_salaries
(salary NUMBER(8,2)) ;

2) 선언 섹션에서 employees 테이블에 있는 상위 n명의 급여를 받는 사원 수를 나타내는 숫자 n을 보유하는 NUMBER 유형의 v_num 변수를 선언한다. 예를 들어, 상위 다섯 개의 급여를 보려면 5 를 입력한다.
   employees.salary 유형의 다른 sal 변수를 선언한다. 
   사원의 급여를 내림차순으로 읽어 들이는 c_emp_cursor 커서를 선언한다.

DECLARE
  v_num NUMBER(3) := 5;
  v_sal employees.salary%TYPE;
  CURSOR c_emp_cursor IS
     SELECT salary
     FROM employees
     ORDER BY salary DESC;

3) 실행 섹션에서 루프를 열고 상위 n개의 급여를 패치(fetch)한 다음 top_salaries 테이블에 삽입한다. 
   간단한 루프를 사용하여 데이터를 산출할 수 있다. 
   또한 종료 조건에 %ROWCOUNT 및 %FOUND 속성을 사용한다.

BEGIN
  OPEN c_emp_cursor;
  FETCH c_emp_cursor INTO v_sal;
  WHILE c_emp_cursor%ROWCOUNT <= v_num AND c_emp_cursor%FOUND
  LOOP
    INSERT INTO top_salaries (salary)
    VALUES (v_sal);
    FETCH c_emp_cursor INTO v_sal;
  END LOOP;
  CLOSE c_emp_cursor;
END;

4) top_salaries 테이블에 삽입한 후 SELECT 문을 사용하여 행을 출력한다. 
   결과로 employees 테이블의 상위 5개의 급여가 출력된다.

/

SELECT * FROM top_salaries;

SALARY
----------
     24000
     17000
     17000
     14000
     13500

5) v_num이 0이거나 v_num이 employees 테이블의 사원 수보다 큰 경우와 같이 다양한 경우를 테스트한다. 
   각 테스트 후에는 top_salaries 테이블을 비운다.

(1) v_num NUMBER(3) := 0; 

TRUNCATE TABLE top_salaries;

SELECT * FROM top_salaries;

no rows selecte

(2) v_num NUMBER(3) := 200; 

TRUNCATE TABLE top_salaries;

SELECT * FROM top_salaries;

SQL> SELECT * FROM top_salaries;

    SALARY
----------
     24000
     17000
...............
      2200
      2100

107 rows selected.


2. 다음을 수행하는 PL/SQL 블록을 생성한다.

1) 선언 섹션에서 NUMBER 유형의 v_deptno 변수를 선언하고 부서 ID 를 보유하는 값을 할당한다.

DECLARE
  v_deptno NUMBER := 10;

2) v_deptno 에 지정된 부서에 근무하는 사원의 last_name, salary 및 manager_id 를 읽어 들이는 
   c_emp_cursor 커서를 선언한다.

  CURSOR c_emp_cursor IS
    SELECT last_name, salary,manager_id
    FROM employees
    WHERE department_id = v_deptno;


3. 실행 섹션에서 커서 FOR 루프를 사용하여 검색된 데이터에 대해 작업할 수 있다. 
  사원의 급여가 5,000 미만이고 관리자 ID 가 101 또는 124 인 경우 
   "<<last_name>> Due for a raise" 메시지를 표시한다. 
   그렇지 않은 경우 "<<last_name>> Not due for a raise" 메시지를 표시한다.

BEGIN
  FOR emp_record IN c_emp_cursor
  LOOP
  IF emp_record.salary < 5000 AND (emp_record.manager_id=101 OR
    emp_record.manager_id=124) THEN
    DBMS_OUTPUT.PUT_LINE (emp_record.last_name || ' Due for a raise');
  ELSE
    DBMS_OUTPUT.PUT_LINE (emp_record.last_name || ' Not Due for a raise');
  END IF;
  END LOOP;
END;

- 다음 경우에 대해 PL/SQL 블록을 테스트한다.

(1) v_deptno NUMBER := 10;

Whalen Due for a raise

(2) v_deptno NUMBER := 20;

Hartstein Not Due for a raise
Fay Not Due for a raise

(3) v_deptno NUMBER := 50;

OConnell Due for a raise
................
Feeney Due for a raise

(4) v_deptno NUMBER := 80; 

Russell Not Due for a raise
................
Johnson Not Due for a raise


4. 파라미터가 포함된 커서를 선언하고 사용하는 PL/SQL 블록을 작성한다.
   루프에서 커서를 사용하여 departments 테이블에서 department_id가 
   100 보다 작은 부서의 부서 번호 및 부서 이름을 읽는다. 
   부서 번호를 다른 커서에 파라미터로 전달하여 employees 테이블에서 해당 부서에 근무하고 
   employee_id가 120 보다 작은 사원의 성, 직위, 채용 날짜 및 급여 등의 상세 정보를 읽는다.

1) 선언 섹션에서 c_dept_cursor 커서를 선언하여 department_id 가 
   100 보다 작은 부서의 department_id 및 department_name 을 읽는다. 
   department_id 에 따라 정렬한다.

DECLARE
  CURSOR c_dept_cursor IS
    SELECT department_id,department_name
    FROM departments
    WHERE department_id < 100
    ORDER BY department_id;

2) 부서 번호를 파라미터로 사용하여 해당 부서에 근무하고 employee_id가 120 보다 작은 사원의 
   last_name, job_id, hire_date 및 salary를 읽어 들이는 다른 커서 c_emp_cursor 를 선언한다.

  CURSOR c_emp_cursor(v_deptno NUMBER) IS
    SELECT last_name,job_id,hire_date,salary
    FROM employees
    WHERE department_id = v_deptno
    AND employee_id < 120;

3) 각 커서에서 검색된 값을 보유하는 변수를 선언한다. 변수 선언 시 %TYPE 속성을 사용한다.

  v_current_deptno departments.department_id%TYPE;
  v_current_dname departments.department_name%TYPE;
  v_ename employees.last_name%TYPE;
  v_job employees.job_id%TYPE;
  v_hiredate employees.hire_date%TYPE;
  v_sal employees.salary%TYPE;

4) c_dept_cursor를 열고 간단한 루프를 사용하여 값을 선언된 변수에 패치(fetch)한다. 
   부서 번호 및 부서 이름을 출력한다.

BEGIN
  OPEN c_dept_cursor;
  LOOP
  FETCH c_dept_cursor INTO
    v_current_deptno,v_current_dname;
  EXIT WHEN c_dept_cursor%NOTFOUND;
  DBMS_OUTPUT.PUT_LINE ('Department Number : ' ||
  v_current_deptno || ' Department Name : ' || v_current_dname);

5) 각 부서에 대해 현재 부서 번호를 파라미터로 전달하여 c_emp_cursor를 연다. 
   다른 루프를 시작하여 emp_cursor의 값을 변수에 패치(fetch)하고 
   employees 테이블에서 검색된 모든 상세 정보를 출력한다.
   주: 각 부서의 상세 정보를 표시한 다음 한 행을 출력할 수 있다. 종료 조건에 적합한 속성을 사용한다. 또한 커서를 열기 전에 이미 열려 있는지 확인한다.

  IF c_emp_cursor%ISOPEN THEN
    CLOSE c_emp_cursor;
  END IF;
  OPEN c_emp_cursor (v_current_deptno);
  LOOP
  FETCH c_emp_cursor INTO v_ename,v_job,v_hiredate,v_sal;
  EXIT WHEN c_emp_cursor%NOTFOUND;
  DBMS_OUTPUT.PUT_LINE (v_ename || ' ' || v_job
  || ' ' || v_hiredate || ' ' ||v_sal);
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('------------------------------------------');
  CLOSE c_emp_cursor;

6) 모든 루프 및 커서를 닫고 실행 섹션을 종료한다. 스크립트를 실행한다.
  END LOOP;
  CLOSE c_dept_cursor;
END;

7) 예제의 출력 결과는 다음과 같다.

Department Number : 10 Department Name : Administration
-----------------------------------------------------------
Department Number : 20 Department Name : Marketing
-----------------------------------------------------------
Department Number : 30 Department Name : Purchasing
Raphaely PU_MAN 07-DEC-02 11000
Khoo PU_CLERK 18-MAY-03 3100
Baida PU_CLERK 24-DEC-05 2900
Tobias PU_CLERK 24-JUL-05 2800
Himuro PU_CLERK 15-NOV-06 2600
Colmenares PU_CLERK 10-AUG-07 2500
-----------------------------------------------------------
Department Number : 40 Department Name : Human Resources
-----------------------------------------------------------
Department Number : 50 Department Name : Shipping
-----------------------------------------------------------
Department Number : 60 Department Name : IT
Hunold IT_PROG 03-JAN-06 9000
Ernst IT_PROG 21-MAY-07 6000
Austin IT_PROG 25-JUN-05 4800
Pataballa IT_PROG 05-FEB-06 4800
Lorentz IT_PROG 07-FEB-07 4200
-----------------------------------------------------------
Department Number : 70 Department Name : Public Relations
-----------------------------------------------------------
Department Number : 80 Department Name : Sales
-----------------------------------------------------------
Department Number : 90 Department Name : Executive
King AD_PRES 17-JUN-03 24000
Kochhar AD_VP 21-SEP-05 17000
De Haan AD_VP 13-JAN-01 17000
-----------------------------------------------------------


===============================
실습 20. 예외 처리
===============================

1. 이 연습의 목적은 미리 정의된 예외의 사용법을 보여주는 것이다. 
   제공된 급여 값을 가진 사원의 이름을 선택하는 PL/SQL 블록을 작성한다.

1) messages 테이블의 모든 레코드를 삭제한다.

DELETE FROM MESSAGES;

2) 선언 섹션에서 employees.last_name 유형의 v_ename 변수와
   employees.salary 유형의 v_emp_sal 변수를 선언한다. 
   v_emp_sal 변수를 6000 으로 초기화한다.

DECLARE
  v_ename employees.last_name%TYPE;
  v_emp_sal employees.salary%TYPE := 6000;

3) 실행 섹션에서 급여가 v_emp_sal 의 값과 동일한 사원의 성을 검색한다.
   주: 명시적 커서를 사용하지 않는다.
   입력된 급여가 행을 하나만 반환하는 경우 messages 테이블에 사원 이름 및 급여를 삽입한다.

BEGIN
  SELECT last_name
  INTO v_ename
  FROM employees
  WHERE salary = v_emp_sal;
  INSERT INTO messages (results)
  VALUES (v_ename || ' - ' || v_emp_sal);

4) 입력된 급여가 행을 반환하지 않으면 적합한 예외 처리기로 예외를 처리하고 
   messages 테이블에 "No employee with a salary of <salary>" 메시지를 삽입한다.

EXCEPTION
  WHEN no_data_found THEN
    INSERT INTO messages (results)
    VALUES ('No employee with a salary of '|| TO_CHAR(v_emp_sal));

5) 입력된 급여가 둘 이상의 행을 반환하면 적합한 예외 처리기로 예외를 처리하고 
   messages 테이블에 "More than one employee with a salary of <salary>" 메시지를 삽입한다.

  WHEN too_many_rows THEN
    INSERT INTO messages (results)
    VALUES ('More than one employee with a salary of '|| TO_CHAR(v_emp_sal));

6) 기타 예외의 경우 적합한 예외 처리기로 처리하고 messages 테이블에 "Some other error occurred" 메시지를 삽입한다.

  WHEN others THEN
    INSERT INTO messages (results)
    VALUES ('Some other error occurred.');
  END;

7) messages 테이블의 행을 표시하여 PL/SQL 블록이 성공적으로 실행되었는지 확인한다. 예제의 출력 결과는 다음과 같다.

/

SELECT * FROM messages;

RESULTS
--------------------------------------------------------------------------------
More than one employee with a salary of 6000


2. 이 연습의 목적은 표준 Oracle Server 오류를 사용하여 예외를 선언하는 방법을 보여주는 것이다. 
   Oracle Server 오류 ORA-02292 (integrity constraint violated - child record found)를 사용한다.

1) 선언 섹션에서 e_childrecord_exists 예외를 선언한다. 
   선언된 예외를 표준 Oracle Server 오류 -02292 와 연결한다.

DECLARE
  e_childrecord_exists EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_childrecord_exists, -02292);

2) 실행 섹션에서 "Deleting department 40...."을 출력한다.
   department_id 가 40 인 부서를 삭제하는 DELETE 문을 포함시킨다.

BEGIN
  DBMS_OUTPUT.PUT_LINE(' Deleting department 40........');
  delete from departments where department_id=40;

3) e_childrecord_exists 예외를 처리하고 적절한 메시지를 출력하는 예외 섹션을 포함시킨다. 

EXCEPTION
  WHEN e_childrecord_exists THEN
    DBMS_OUTPUT.PUT_LINE(' Cannot delete this department. There
      are employees in this department (child records exist.) ');
END;

4) 예제의 출력 결과는 다음과 같다.

Deleting department 40........
Cannot delete this department. There
are employees in this department (child records exist.)


===============================
실습 21. 내장 프로시저 생성	
===============================

1. ADD_JOB 프로시저를 생성하여 호출한 다음 결과를 검토한다.

1) JOBS 테이블에 새로운 직무를 삽입하는 ADD_JOB이라는 프로시저를 생성한다.
   두 개의 파라미터를 사용하여 직무 ID와 직위를 제공한다.

CREATE OR REPLACE PROCEDURE add_job (
  jobid jobs.job_id%TYPE,
  jobtitle jobs.job_title%TYPE) IS
BEGIN
  INSERT INTO jobs (job_id, job_title)
  VALUES (jobid, jobtitle);
  COMMIT;
END add_job;
/

2) 코드를 컴파일한 다음 IT_DBA를 직무 ID로 사용하고 Database Administrator를 직위로 사용하는 프로시저를 호출한다. 
   JOBS 테이블을 query하여 결과를 확인한다.

EXECUTE add_job ('IT_DBA', 'Database Administrator')

SELECT * FROM jobs WHERE job_id = 'IT_DBA';

JOB_ID     JOB_TITLE                           MIN_SALARY MAX_SALARY
---------- -----------------------------------     ----------             ----------
IT_DBA     Database Administrator

3) 프로시저를 다시 호출하여 직무 ID ST_MAN과 직위 Stock Manager를 전달한다. 
   어떤 결과가 발생하며 그 이유는 무엇인가?

EXECUTE add_job ('ST_MAN', 'Stock Manager')

BEGIN add_job ('ST_MAN', 'Stock Manager'); END;
*
ERROR at line 1:
ORA-00001: unique constraint (HR.JOB_ID_PK) violated
ORA-06512: at "HR.ADD_JOB", line 5
ORA-06512: at line 1
JOB_ID 열에 대한 primary key 무결성 제약 조건이 있기 때문에 예외가 발생한다.


2. JOBS 테이블의 직무를 수정하는 UPD_JOB이라는 프로시저를 생성한다.

1) 직위를 갱신하는 UPD_JOB이라는 프로시저를 생성한다. 
   두 개의 파라미터를 사용하여 직무 ID와 새로운 직위를 제공한다. 
   갱신이 수행되지 않을 경우에 필요한 예외 처리를 추가한다.

CREATE OR REPLACE PROCEDURE upd_job(
  jobid IN jobs.job_id%TYPE,
  jobtitle IN jobs.job_title%TYPE) IS
BEGIN
  UPDATE jobs
  SET job_title = jobtitle
  WHERE job_id = jobid;
  IF SQL%NOTFOUND THEN
    RAISE_APPLICATION_ERROR(-20202, 'No job updated.');
  END IF;
END upd_job;
/

2) 코드를 컴파일한 다음 직무 ID IT_DBA의 직위를 Data Administrator로 변경하는 프로시저를 호출한다. 
   JOBS 테이블을 query하여 결과를 확인한다.

EXECUTE upd_job ('IT_DBA', 'Data Administrator')

SELECT * FROM jobs WHERE job_id = 'IT_DBA';

JOB_ID     JOB_TITLE                           MIN_SALARY MAX_SALARY
---------- -----------------------------------     ----------              ----------
IT_DBA     Data Administrator

3) 존재하지 않는 직무를 갱신해 봄으로써 예외 처리도 확인한다. 
   직무 ID IT_WEB과 직위 Web Master를 사용할 수도 있다.

EXECUTE upd_job ('IT_WEB', 'Web Master')

BEGIN upd_job ('IT_WEB', 'Web Master'); END;
*
ERROR at line 1:
ORA-20202: No job updated.
ORA-06512: at "HR.UPD_JOB", line 9
ORA-06512: at line 1


3. JOBS 테이블에서 직무를 삭제하는 DEL_JOB이라는 프로시저를 생성한다. 

1) 직무를 삭제하는 DEL_JOB이라는 프로시저를 생성한다. 직무가 삭제되지 않을 경우에 필요한 예외 처리를 추가한다.

CREATE OR REPLACE PROCEDURE del_job (jobid jobs.job_id%TYPE) IS
BEGIN
  DELETE FROM jobs
  WHERE job_id = jobid;
  IF SQL%NOTFOUND THEN
    RAISE_APPLICATION_ERROR(-20203, 'No jobs deleted.');
  END IF;
END DEL_JOB;
/

2) 코드를 컴파일하고 직무 ID IT_DBA를 사용하여 프로시저를 호출한다. 
   JOBS 테이블을 query하여 결과를 확인한다.

EXECUTE del_job ('IT_DBA')

SELECT * FROM jobs WHERE job_id = 'IT_DBA';

no rows selected

3) 존재하지 않는 직무를 삭제해 봄으로써 예외 처리도 확인한다. 
   IT_WEB을 직무 ID로 사용한다. 프로시저의 예외 처리 섹션에 사용했던 메시지가 출력되어야 한다.

EXECUTE del_job ('IT_WEB')

BEGIN del_job ('IT_WEB'); END;
*
ERROR at line 1:
ORA-20203: No jobs deleted.
ORA-06512: at "HR.DEL_JOB", line 6
ORA-06512: at line 1


4. 사원 ID를 제공할 경우 사원의 급여와 직무 ID를 검색하는 GET_EMPLOYEE라는
   프로시저를 생성하여 EMPLOYEES 테이블을 query한다.

1) 지정된 사원 ID에 대한 SALARY 및 JOB_ID 열에서 값을 반환하는 프로시저를 생성한다. 
   코드를 컴파일한 다음 구문 오류를 제거한다.

CREATE OR REPLACE PROCEDURE get_employee
  (empid IN employees.employee_id%TYPE,
  sal OUT employees.salary%TYPE,
  job OUT employees.job_id%TYPE) IS
BEGIN
  SELECT salary, job_id
  INTO sal, job
  FROM employees
  WHERE employee_id = empid;
END get_employee;
/

2) 두 개의 OUT 파라미터, 즉 급여에 대한 파라미터와 직무 ID에 대한 파라미터에 
   호스트 변수를 사용하여 프로시저를 실행한다. 사원 ID 120에 대한 급여와 직무 ID를 표시한다.

VARIABLE salary NUMBER
VARIABLE job VARCHAR2(15)

EXECUTE get_employee(120, :salary, :job)

PRINT salary job

SALARY
----------
      8000

JOB
--------------------------------
ST_MAN

3) 프로시저를 다시 호출하여 EMPLOYEE_ID 300을 전달한다. 
  어떤 결과가 발생하며 그 이유는 무엇인가?

EXECUTE get_employee(300, :salary, :job)

BEGIN get_employee(300, :salary, :job); END;
*
ERROR at line 1:
ORA-01403: no data found
ORA-06512: at "HR.GET_EMPLOYEE", line 6
ORA-06512: at line 1
EMPLOYEES 테이블에는 EMPLOYEE_ID가 300인 사원이 없다. SELECT 문이 데이터베이스에서 데이터를 읽어 들일 수 없으므로 치명적인 PL/SQL 오류 NO_DATA_FOUND가 발생한다.


===============================
실습 22. 내장 함수 생성
===============================

1. 직위를 반환하는 GET_JOB 함수를 생성하여 호출한다.

1) 직위를 반환하는 GET_JOB 함수를 생성하여 컴파일한다.

CREATE OR REPLACE FUNCTION get_job (jobid IN jobs.job_id%type )
  RETURN jobs.job_title%type IS
  title jobs.job_title%type;
BEGIN
  SELECT job_title
  INTO title
  FROM jobs
  WHERE job_id = jobid;
  RETURN title;
END get_job;
/

2) 최대 35자가 허용되는 TITLE이라는 VARCHAR2 호스트 변수를 생성한다. 
   직무ID SA_REP로 함수를 호출하여 호스트 변수의 값을 반환한다. 호스트 변수를 출력하여 결과를 확인한다.

VARIABLE title VARCHAR2(35)

EXECUTE :title := get_job ('SA_REP');

PRINT title

TITLE
--------------------------------------------------------------------------------
Sales Representative


2. 파라미터로 전달된 사원의 월급과 커미션에서 계산된 연봉을 반환하는 GET_ANNUAL_COMP라는 함수를 생성한다.

1) 월급과 커미션에 대해 파라미터 값을 사용하는 GET_ANNUAL_COMP 함수를 개발하고 저장한다. 
   두 값 중 하나 또는 두 값 모두 NULL일 수는 있지만 함수가 반환하는 연봉은 NULL이 아니어야 한다. 
   다음과 같은 기본 공식을 사용하여 연봉을 계산한다.
  (salary*12) + (commission_pct*salary*12)

CREATE OR REPLACE FUNCTION get_annual_comp(
  sal IN employees.salary%TYPE,
  comm IN employees.commission_pct%TYPE)
  RETURN NUMBER IS
BEGIN
  RETURN (NVL(sal,0) * 12 + (NVL(comm,0) * nvl(sal,0) * 12));
END get_annual_comp;
/

2) EMPLOYEES 테이블에 대한 SELECT 문에서 부서 30에 근무하는 사원에 대해 이 함수를 사용한다.

SELECT employee_id, last_name,
       get_annual_comp(salary,commission_pct) "Annual Compensation"
FROM employees
WHERE department_id=30 ;

EMPLOYEE_ID LAST_NAME                 Annual Compensation
----------- ------------------------- -------------------
        114 Raphaely                               132000
        115 Khoo                                    37200
        116 Baida                                   34800
        117 Tobias                                  33600
        118 Himuro                                  31200
        119 Colmenares                              30000


3. EMPLOYEES 테이블에 새로운 사원을 삽입하는 ADD_EMPLOYEE라는 프로시저를 생성한다. 
   이 프로시저는 VALID_DEPTID 함수를 호출하여 새로운 사원에게 
   지정된 부서 ID가 DEPARTMENTS 테이블에 있는지 여부를 확인해야 한다.

1) 지정된 부서 ID를 검증한 다음 해당 부서가 존재할 경우 BOOLEAN 값 TRUE를 반환하는 VALID_DEPTID 함수를 생성한다.

CREATE OR REPLACE FUNCTION valid_deptid(
  deptid IN departments.department_id%TYPE)
  RETURN BOOLEAN IS
  dummy PLS_INTEGER;
BEGIN
  SELECT 1
  INTO dummy
  FROM departments
  WHERE department_id = deptid;
  RETURN TRUE;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN FALSE;
END valid_deptid;
/

2) EMPLOYEES 테이블에 사원을 추가하는 ADD_EMPLOYEE 프로시저를 생성한다.
   VALID_DEPTID 함수가 TRUE를 반환할 경우 EMPLOYEES 테이블에 행이 추가되어야 하며, 
   그렇지 않을 경우 적절한 메시지를 표시하여 유저에게 경고해야 한다. 
   first_name, last_name, email, job (SA_REP), mgr (145), sal (1000), 
   comm (0), deptid (30) 파라미터를 제공한다(괄호 안에 지정된 기본값 사용). 
   EMPLOYEES_SEQ 시퀀스를 사용하여 employee_id 열을 설정하고 hire_date를 TRUNC(SYSDATE)로 설정한다.


CREATE OR REPLACE PROCEDURE add_employee(
  first_name employees.first_name%TYPE,
  last_name employees.last_name%TYPE,
  email employees.email%TYPE,
  job employees.job_id%TYPE DEFAULT 'SA_REP',
  mgr employees.manager_id%TYPE DEFAULT 145,
  sal employees.salary%TYPE DEFAULT 1000,
  comm employees.commission_pct%TYPE DEFAULT 0,
  deptid employees.department_id%TYPE DEFAULT 30) IS
BEGIN
  IF valid_deptid(deptid) THEN
    INSERT INTO employees(employee_id, first_name, last_name, email,
      job_id, manager_id, hire_date, salary, commission_pct,department_id)
    VALUES (employees_seq.NEXTVAL, first_name, last_name, email,
      job, mgr, TRUNC(SYSDATE), sal, comm, deptid);
  ELSE
    RAISE_APPLICATION_ERROR (-20204, 'Invalid department ID. Try again.');
  END IF;
END add_employee;
/

3) 부서 15에 근무하는 Jane Harris에 대해 ADD_EMPLOYEE를 호출하되, 
   다른 파라미터는 기본값을 그대로 적용한다. 어떤 결과가 발생하는가?
주: 데이터베이스 서버 시간 범위가 8:00에서 18:00 사이가 아닌 경우, Secure_employees 트리거는 EMPLOYEES 테이블에서 DML 작업을 수행할 때 실행된다. 이 문제를 해결하려면 트리거를 비활성화한다. ALTER TRIGGER secure_employees DISABLE;

EXECUTE add_employee('Jane', 'Harris', 'JAHARRIS', deptid=> 15)

BEGIN add_employee('Jane', 'Harris', 'JAHARRIS', deptid=> 15); END;
*
ERROR at line 1:
ORA-20204: Invalid department ID. Try
again.
ORA-06512: at "HR.ADD_EMPLOYEE", line 17
ORA-06512: at line 1

4) 부서 80에 Joe Harris라는 또 다른 사원을 추가하되, 나머지 파라미터는
   기본값을 그대로 적용한다. 어떤 결과가 발생하는가?

EXECUTE add_employee('Joe', 'Harris', 'JAHARRIS', deptid=> 80)

SELECT first_name, last_name, email, department_id 
FROM employees
WHERE first_name = 'Joe';

FIRST_NAME     LAST_NAME          EMAIL            DEPARTMENT_ID
--------------------   -------------------------  -----------------   ---------------------
Joe                        Harris                        JAHARRIS           80


===============================
실습 23. 패키지 생성
===============================

1. ADD_JOB, UPD_JOB 및 DEL_JOB 프로시저의 복사본과 GET_JOB 함수가 포함된 
   JOB_PKG라는 Package Spec과 Body를 생성한다.
주: 패키지를 생성할 때는 이전에 저장한 프로시저 및 함수의 코드를 사용한다. 
   프로시저 또는 함수에서 코드를 복사하여 패키지의 적절한 부분에 붙여넣을 수 있다.

1) 프로시저와 함수 머리글이 공용(public) 생성자로 포함된 Package Spec을생성한다.

CREATE OR REPLACE PACKAGE job_pkg IS
  PROCEDURE add_job (jobid jobs.job_id%TYPE, jobtitle jobs.job_title%TYPE);
  PROCEDURE del_job (jobid jobs.job_id%TYPE);
  FUNCTION get_job (jobid IN jobs.job_id%type) RETURN jobs.job_title%type;
  PROCEDURE upd_job(jobid IN jobs.job_id%TYPE, jobtitle IN jobs.job_title%TYPE);
END job_pkg;
/


2) 각 서브 프로그램을 구현하여 Package Body를 생성한다.

CREATE OR REPLACE PACKAGE BODY job_pkg IS
  PROCEDURE add_job (jobid jobs.job_id%TYPE, 
    jobtitle jobs.job_title%TYPE) IS
  BEGIN
    INSERT INTO jobs (job_id, job_title)
    VALUES (jobid, jobtitle);
    COMMIT;
  END add_job;
  PROCEDURE del_job (jobid jobs.job_id%TYPE) IS
  BEGIN
    DELETE FROM jobs
    WHERE job_id = jobid;
    IF SQL%NOTFOUND THEN
      RAISE_APPLICATION_ERROR(-20203, 'No jobs deleted.');
    END IF;
  END DEL_JOB;
  FUNCTION get_job (jobid IN jobs.job_id%type)
  RETURN jobs.job_title%type IS
  title jobs.job_title%type;
  BEGIN
    SELECT job_title
    INTO title
    FROM jobs
    WHERE job_id = jobid;
  RETURN title;
  END get_job;
  PROCEDURE upd_job(jobid IN jobs.job_id%TYPE,
    jobtitle IN jobs.job_title%TYPE) IS
  BEGIN
    UPDATE jobs
    SET job_title = jobtitle
    WHERE job_id = jobid;
    IF SQL%NOTFOUND THEN
      RAISE_APPLICATION_ERROR(-20202, 'No job updated.');
    END IF;
  END upd_job;
END job_pkg;
/

3) IT_SYSAN 및 Systems Analyst 값을 파라미터로 전달하여 ADD_JOB 패키지 프로시저를 호출한다.

EXECUTE job_pkg.add_job('IT_SYSAN', 'Systems Analyst')

4) JOBS 테이블을 query하여 결과를 확인한다.

SELECT *
FROM jobs
WHERE job_id = 'IT_SYSAN';

JOB_ID     JOB_TITLE          MIN_SALARY  MAX_SALARY
---------- ----------------- ----------   ----------
IT_SYSAN   Systems Analyst


2. 전용(Private) 생성자와 공용(Public) 생성자가 포함된 패키지를 생성하여 호출한다.

1) ADD_EMPLOYEE 및 GET_EMPLOYEE 프로시저가 공용 생성자로 포함된 
   EMP_PKG라는 Package Spec과 Body를 생성한 다음 VALID_DEPTID 함수를 전용 생성자로 삽입한다.

Package Spec:
CREATE OR REPLACE PACKAGE emp_pkg IS
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30);
  PROCEDURE get_employee(
   empid IN employees.employee_id%TYPE,
   sal OUT employees.salary%TYPE,
   job OUT employees.job_id%TYPE);
END emp_pkg;
/

SHOW ERRORS

Package Body:
CREATE OR REPLACE PACKAGE BODY emp_pkg IS
  FUNCTION valid_deptid(deptid IN departments.department_id%TYPE)
  RETURN BOOLEAN IS
  dummy PLS_INTEGER;
  BEGIN
    SELECT 1
    INTO dummy
    FROM departments
    WHERE department_id = deptid;
  RETURN TRUE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN FALSE;
  END valid_deptid;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30) IS
  BEGIN
    IF valid_deptid(deptid) THEN
      INSERT INTO employees(employee_id, first_name, last_name, email,
      job_id,manager_id,hire_date,salary,commission_pct,department_id)
      VALUES (employees_seq.NEXTVAL, first_name, last_name, email,
      job, mgr, TRUNC(SYSDATE), sal, comm, deptid);
    ELSE
      RAISE_APPLICATION_ERROR (-20204,
        'Invalid department ID. Try again.');
    END IF;
  END add_employee;
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE) IS
  BEGIN
    SELECT salary, job_id
    INTO sal, job
    FROM employees
    WHERE employee_id = empid;
  END get_employee;
END emp_pkg;
/

SHOW ERRORS

2) 전자 메일이 JAHARRIS인 사원 Jane Harris의 부서 ID 15를 사용하여 
   EMP_PKG.GET_EMPLOYEE 프로시저를 호출한다. 
   부서 ID 15는 존재하지 않으므로 프로시저의 예외 처리기에 지정된 대로 오류 메시지가 표시되어야 한다.

EXECUTE emp_pkg.add_employee('Jane', 'Harris','JAHARRIS', deptid => 15)

BEGIN emp_pkg.add_employee('Jane', 'Harris','JAHARRIS', deptid => 15); END;
*
ERROR at line 1:
ORA-20204: Invalid department ID. Try again.
ORA-06512: at "HR.EMP_PKG", line 31
ORA-06512: at line 1

3) 전자 메일이 DASMITH인 사원 David Smith의 부서 ID 80을 사용하여
   ADD_EMPLOYEE 패키지 프로시저를 호출한다.

EXECUTE emp_pkg.add_employee('David', 'Smith','DASMITH', deptid => 80)

SELECT first_name, last_name, email, department_id 
FROM employees
WHERE email = 'DASMITH';

FIRST_NAME     LAST_NAME          EMAIL            DEPARTMENT_ID
--------------------   -------------------------  -----------------   ---------------------
David                  Smith                         DASMITH           80


===============================
실습 24. 패키지 작업
===============================

1. 연습 23의 연습 문제 2에서 생성한 EMP_PKG 패키지의 코드를 복사하고 수정한 다음 
   ADD_EMPLOYEE 프로시저를 오버로드한다.

1) Package Spec에서 세 개의 파라미터(성, 이름, 부서 ID)를 사용하는 
   ADD_EMPLOYEE라는 새 프로시저를 추가한다. 변경 사항을 저장하고 컴파일한다.

CREATE OR REPLACE PACKAGE emp_pkg IS
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30);
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE);
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE);
END emp_pkg;
/


2) 이름의 첫 자와 성의 처음 일곱 자를 연결하여 대문자로 전자 메일 주소를 지정하도록 
   Package Body에서 새 ADD_EMPLOYEE 프로시저를 구현한다.
   이 프로시저는 기존의 ADD_EMPLOYEE 프로시저를 호출하여 해당 파라미터와 형식이 지정된 
   전자 메일을 통해 값을 제공하여 실제 INSERT 작업을 수행해야 한다. 변경 사항을 저장하고 컴파일한다.

CREATE OR REPLACE PACKAGE BODY emp_pkg IS
  FUNCTION valid_deptid(deptid IN departments.department_id%TYPE)
  RETURN BOOLEAN IS
  dummy PLS_INTEGER;
  BEGIN
    SELECT 1
    INTO dummy
    FROM departments
    WHERE department_id = deptid;
  RETURN TRUE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN FALSE;
  END valid_deptid;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30) IS
  BEGIN
    IF valid_deptid(deptid) THEN
      INSERT INTO employees(employee_id, first_name, last_name, email,
      job_id,manager_id,hire_date,salary,commission_pct,department_id)
      VALUES (employees_seq.NEXTVAL, first_name, last_name, email,
      job, mgr, TRUNC(SYSDATE), sal, comm, deptid);
    ELSE
     RAISE_APPLICATION_ERROR (-20204,
     'Invalid department ID. Try again.');
    END IF;
  END add_employee;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE) IS
    email employees.email%type;
  BEGIN
    email := UPPER(SUBSTR(first_name, 1, 1)||SUBSTR(last_name, 1, 7));
    add_employee(first_name, last_name, email, deptid => deptid);
  END;
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE) IS
  BEGIN
    SELECT salary, job_id
    INTO sal, job
    FROM employees
    WHERE employee_id = empid;
  END get_employee;
END emp_pkg;
/

3) 부서 30에 추가될 Samuel Joplin이라는 이름을 사용하여 
   새 ADD_EMPLOYEE 프로시저를 호출한다.

EXECUTE emp_pkg.add_employee('Samuel', 'Joplin', 30)

SELECT first_name, last_name, email, department_id 
FROM employees
WHERE last_name = 'Joplin';

FIRST_NAME     LAST_NAME          EMAIL            DEPARTMENT_ID
--------------------   -------------------------  -----------------   ---------------------
Samuel               Joplin                    SJOPLIN                 30


2. EMP_PKG 패키지에서 GET_EMPLOYEE라는 두 개의 오버로드된 함수를 생성한다.

1) Spec에서, employees.employee_id%TYPE 유형 기반의 emp_id 파라미터를 사용하는 
   GET_EMPLOYEE 함수를 추가한 다음 employees.last_name%TYPE 유형의 
   family_name 파라미터를 사용하는 두번째 GET_EMPLOYEE 함수를 추가한다. 
   두 함수 모두 EMPLOYEES%ROWTYPE을 반환해야 한다. 변경 사항을 저장하고 컴파일한다.

CREATE OR REPLACE PACKAGE emp_pkg IS
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30);
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE);
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE);
  FUNCTION get_employee(emp_id employees.employee_id%type)
    return employees%rowtype;
  FUNCTION get_employee(family_name employees.last_name%type)
    return employees%rowtype;
END emp_pkg;
/

2) Package Body에서 첫번째 GET_EMPLOYEE 함수는 사원 ID로 사원을 query하도록 구현하고, 
  두번째 함수는 family_name 파라미터에 제공된 값에 등호 연산자를 사용하도록 구현한다. 
  변경 사항을 저장하고 컴파일한다.

CREATE OR REPLACE PACKAGE BODY emp_pkg IS
  FUNCTION valid_deptid(deptid IN departments.department_id%TYPE)
    RETURN BOOLEAN IS
    dummy PLS_INTEGER;
    BEGIN
      SELECT 1
      INTO dummy
      FROM departments
      WHERE department_id = deptid;
    RETURN TRUE;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
      RETURN FALSE;
    END valid_deptid;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30) IS
  BEGIN
    IF valid_deptid(deptid) THEN
      INSERT INTO employees(employee_id, first_name, last_name, email,
        job_id,manager_id,hire_date,salary,commission_pct,department_id)
      VALUES (employees_seq.NEXTVAL, first_name, last_name, email,
        job, mgr, TRUNC(SYSDATE), sal, comm, deptid);
    ELSE
      RAISE_APPLICATION_ERROR (-20204,
        'Invalid department ID. Try again.');
    END IF;
  END add_employee;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE) IS
    email employees.email%type;
  BEGIN
    email := UPPER(SUBSTR(first_name, 1, 1)||SUBSTR(last_name, 1, 7));
    add_employee(first_name, last_name, email, deptid => deptid);
  END;
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE) IS
  BEGIN
    SELECT salary, job_id
    INTO sal, job
    FROM employees
    WHERE employee_id = empid;
  END get_employee;
  FUNCTION get_employee(emp_id employees.employee_id%type)
    return employees%rowtype IS
    emprec employees%rowtype;
  BEGIN
    SELECT * INTO emprec
    FROM employees
    WHERE employee_id = emp_id;
  RETURN emprec;
  END;
  FUNCTION get_employee(family_name employees.last_name%type)
    return employees%rowtype IS
    emprec employees%rowtype;
  BEGIN
    SELECT * INTO emprec
    FROM employees
    WHERE last_name = family_name;
    RETURN emprec;
  END;
END emp_pkg;
/

3) EMPLOYEES%ROWTYPE을 파라미터로 사용하고 DBMS_OUTPUT을 사용하여 
   사원의 department_id, employee_id, first_name, last_name, job_id 및 
   salary를 한 줄에 표시하는 유틸리티 프로시저 PRINT_EMPLOYEE를 패키지에 추가한다. 
   변경 사항을 저장하고 컴파일한다.

CREATE OR REPLACE PACKAGE emp_pkg IS
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30);
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE);
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE);
  FUNCTION get_employee(emp_id employees.employee_id%type)
    return employees%rowtype;
  FUNCTION get_employee(family_name employees.last_name%type)
    return employees%rowtype;
  PROCEDURE print_employee(emprec employees%rowtype);
END emp_pkg;
/

CREATE OR REPLACE PACKAGE BODY emp_pkg IS
  FUNCTION valid_deptid(deptid IN departments.department_id%TYPE)
    RETURN BOOLEAN IS
    dummy PLS_INTEGER;
  BEGIN
    SELECT 1
    INTO dummy
    FROM departments
    WHERE department_id = deptid;
  RETURN TRUE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN FALSE;
  END valid_deptid;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30) IS
  BEGIN
    IF valid_deptid(deptid) THEN
      INSERT INTO employees(employee_id, first_name, last_name, email,
        job_id,manager_id,hire_date,salary,commission_pct,department_id)
      VALUES (employees_seq.NEXTVAL, first_name, last_name, email,
        job, mgr, TRUNC(SYSDATE), sal, comm, deptid);
    ELSE
      RAISE_APPLICATION_ERROR (-20204,
       'Invalid department ID. Try again.');
    END IF;
  END add_employee;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE) IS
    email employees.email%type;
  BEGIN
    email := UPPER(SUBSTR(first_name, 1, 1)||SUBSTR(last_name, 1, 7));
    add_employee(first_name, last_name, email, deptid => deptid);
  END;
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE) IS
  BEGIN
    SELECT salary, job_id
    INTO sal, job
    FROM employees
    WHERE employee_id = empid;
  END get_employee;
  FUNCTION get_employee(emp_id employees.employee_id%type)
    return employees%rowtype IS
    emprec employees%rowtype;
  BEGIN
    SELECT * INTO emprec
    FROM employees
    WHERE employee_id = emp_id;
  RETURN emprec;
  END;
  FUNCTION get_employee(family_name employees.last_name%type)
    return employees%rowtype IS
    emprec employees%rowtype;
  BEGIN
    SELECT * INTO emprec
    FROM employees
    WHERE last_name = family_name;
  RETURN emprec;
  END;
  PROCEDURE print_employee(emprec employees%rowtype) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(emprec.department_id ||' '||
      emprec.employee_id||' '||
      emprec.first_name||' '||
      emprec.last_name||' '||
      emprec.job_id||' '||
      emprec.salary);
     END;
END emp_pkg;
/

4) 익명 블록을 사용하여 사원 ID 100과 성 'Joplin'으로 EMP_PKG.GET_EMPLOYEE 함수를 호출한다. 
   PRINT_EMPLOYEE 프로시저를 사용하여 각 행에 대해 반환된 결과를 표시한다.

BEGIN
  emp_pkg.print_employee(emp_pkg.get_employee(100));
  emp_pkg.print_employee(emp_pkg.get_employee('Joplin'));
END;
/

90 100 Steven King AD_PRES 24000
30 209 Samuel Joplin SA_REP 1000


3. EMP_PKG Package Body를 래핑한 다음 재생성한다.

1) 데이터 딕셔너리를 query하여 EMP_PKG Body의 소스를 확인한다.
SELECT text
FROM user_source
WHERE name = 'EMP_PKG'
AND type = 'PACKAGE BODY'
ORDER BY line;

2) WRAP 명령행 유틸리티를 실행하여 EMP_PKG 패키지의 Body를 래핑한다. 
  출력 파일의 확장자를 .plb로 지정한다.
  힌트: Package Body를 포함하는 파일을 emp_pkg_b.sql이라는 파일에 저장한다.

$ vi emp_pkg_b.sql

$ wrap iname=emp_pkg_b.sql

3) SQL Developer를 사용하여 래핑된 소스가 포함된 .plb 파일을 열고 컴파일한다.

SQL> @emp_pkg_b.plb

4) 데이터 딕셔너리를 query하여 EMP_PKG Package Body의 소스를 다시 표시한다.
   원본 소스 코드 행이 판독 가능한가?

SELECT text
FROM user_source
WHERE name = 'EMP_PKG'
AND type = 'PACKAGE BODY'
ORDER BY line;

Body의 소스 코드는 더 이상 판독 가능하지 않다. 
래핑된 소스를 볼 수는 있지만 원본 소스 코드가 표시되지 않는다. 
따라서 WRAP 유틸리티를 사용할 경우 소스 코드의 안전한 복사본을 항상 데이터베이스 외부의 파일에 저장한다.


===============================
실습 25. PL/SQL 코드 설계 고려 사항
===============================

1. CURRENT_USER의 AUTHID를 사용하도록 EMP_PKG 패키지를 수정한 다음 다른 사용자 scott과 함께 동작을 테스트한다.

1) EMP_PKG 패키지의 EXECUTE 권한을 scott에게 부여한다.

GRANT EXECUTE ON EMP_PKG TO scott;

2) scott 권한으로 hr의 add_employee 프로시저를 호출하여 부서 10에 근무하는 Jaco Pastorius라는 사원을 삽입한다. 패키지 이름 앞에 패키지 소유자를 붙인다. 호출은 정의자 권한으로 실행해야 한다.

conn scott/tiger

EXECUTE hr.emp_pkg.add_employee('Jaco', 'Pastorius', 10)

3) 이제 HR을 사용하여 부서 10의 사원에 대한 query를 실행한다. 사원 테이블에 새 레코드가 삽입되었는가?

conn hr/hr

SELECT department_id, first_name, last_name
FROM employees
WHERE department_id = 10;

DEPARTMENT_ID FIRST_NAME           LAST_NAME
------------- -------------------- -------------------------
           10 Jennifer             Whalen
           10 Jaco                 Pastorius

새로운 사원이 HR 스키마의 테이블, 즉 EMP_PKG 패키지 소유자의 테이블에 추가되었다.

4) 이제 AUTHID CURRENT_USER를 사용하도록 ora61의 패키지 EMP_PKG Spec을 수정한다. EMP_PKG Body를 컴파일한다.

CREATE OR REPLACE PACKAGE emp_pkg AUTHID CURRENT_USER IS
  TYPE emp_tabtype IS TABLE OF employees%ROWTYPE;
  PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    email employees.email%TYPE,
    job employees.job_id%TYPE DEFAULT 'SA_REP',
    mgr employees.manager_id%TYPE DEFAULT 145,
    sal employees.salary%TYPE DEFAULT 1000,
    comm employees.commission_pct%TYPE DEFAULT 0,
    deptid employees.department_id%TYPE DEFAULT 30);
    PROCEDURE add_employee(
    first_name employees.first_name%TYPE,
    last_name employees.last_name%TYPE,
    deptid employees.department_id%TYPE);
  PROCEDURE get_employee(
    empid IN employees.employee_id%TYPE,
    sal OUT employees.salary%TYPE,
    job OUT employees.job_id%TYPE);
  FUNCTION get_employee(emp_id employees.employee_id%type)
    return employees%rowtype;
  FUNCTION get_employee(family_name employees.last_name%type)
    return employees%rowtype;
  PROCEDURE get_employees(dept_id employees.department_id%type);
  PROCEDURE init_departments;
  PROCEDURE print_employee(emprec employees%rowtype);
  PROCEDURE show_employees;
END emp_pkg;
/

5) scott으로 add_employee 프로시저를 다시 실행하여 부서 10에 Joe Zawinal 사원을 추가한다. 
   새로운 사원이 추가되었는가?
  주: emp_pkg.add_employee를 실행하기 전에 log_newemp 테이블이 생성되도록 다음 스크립트를 실행한다.

conn scott/tiger

CREATE TABLE log_newemp (
  entry_id  NUMBER(6) CONSTRAINT log_newemp_pk PRIMARY KEY,
  user_id   VARCHAR2(30),
  log_time  DATE,
  name      VARCHAR2(60));

CREATE SEQUENCE log_newemp_seq;

EXECUTE hr.emp_pkg.add_employee('Joe', 'Zawinal', 10)
BEGIN hr.emp_pkg.add_employee('Joe', 'Zawinal', 10); END;
*
ERROR at line 1:
ORA-00942: table or view does not exist
ORA-06512: at "HR.EMP_PKG", line 83
ORA-06512: at "HR.EMP_PKG", line 117
ORA-06512: at line 1

새로운 사원이 사원 테이블에 추가되지 않는다. 패키지 프로시저 호출자(scott)는 사원 테이블에 입력 권한이 없다.


===============================
실습 26. 트리거 생성
===============================

1. JOBS 테이블의 행에는 여러 JOB_ID 값에 허용되는 최대 급여와 최소 급여가 저장된다. 
   INSERT 및 UPDATE 작업을 위해 사원의 급여가 그들의 직무 유형에 허용되는 범위 내에 있도록 하는 
   코드를 작성하라는 요청을 받았다.

1) 사원의 직무 ID 문자열에 대한 파라미터와 급여에 대한 파라미터를 사용하는 
   CHECK_SALARY라는 프로시저를 작성한다. 
   프로시저는 직무 ID를 사용하여 지정된 직무의 최소 급여와 최대 급여를 결정한다. 
   급여 파라미터가 직무의 급여 범위(최소 급여 및 최대 급여 포함)에 속하지 않을 경우 
   Invalid salary<sal>. Salaries for job <jobid> must be between 
   <min> and <max>(이)라는 메시지와 함께 응용 프로그램 예외가 발생해야 한다.
   메시지의 여러 항목을 Query에 의해 채워지는 파라미터와 변수가 제공하는 값으로 바꾼다. 

CREATE OR REPLACE PROCEDURE check_salary 
(the_job VARCHAR2, the_salary NUMBER) IS
  minsal jobs.min_salary%type;
  maxsal jobs.max_salary%type;
  BEGIN
    SELECT min_salary, max_salary INTO minsal, maxsal
    FROM jobs
    WHERE job_id = UPPER(the_job);
    IF the_salary NOT BETWEEN minsal AND maxsal THEN
      RAISE_APPLICATION_ERROR(-20100,
        'Invalid salary $'||the_salary||'. '||
        'Salaries for job '|| the_job ||
        ' must be between $'|| minsal ||' and $' || maxsal);
    END IF;
END;
/

2) 각 행에 대한 INSERT 또는 UPDATE 작업 이전에 실행되는 
   CHECK_SALARY_TRG라는 트리거를 EMPLOYEES 테이블에 생성한다. 
   트리거는 CHECK_SALARY 프로시저를 호출하여 업무 논리를 수행해야 한다. 
   트리거는 새로운 직무 ID와 급여를 프로시저 파라미터에 전달해야 한다.

CREATE OR REPLACE TRIGGER check_salary_trg
BEFORE INSERT OR UPDATE OF job_id, salary
ON employees
FOR EACH ROW
BEGIN
  check_salary(:new.job_id, :new.salary);
END;
/


2. 다음과 같은 경우를 통해 CHECK_SAL_TRG를 테스트한다.

1) EMP_PKG.ADD_EMPLOYEE 프로시저를 사용하여 부서 30에 Eleanor Beh라는 사원을 추가한다. 
   어떤 결과가 발생하며 그 이유는 무엇인가?

EXECUTE emp_pkg.add_employee('Eleanor', 'Beh', 30)

BEGIN emp_pkg.add_employee('Eleanor', 'Beh', 30); END;
*
ERROR at line 1:
ORA-20100: Invalid salary $1000. Salaries for job SA_REP must be between $6000
and $12008
ORA-06512: at "HR.CHECK_SALARY", line 10
ORA-06512: at "HR.CHECK_SALARY_TRG", line 2
ORA-04088: error during execution of trigger 'HR.CHECK_SALARY_TRG'
ORA-06512: at "HR.EMP_PKG", line 29
ORA-06512: at "HR.EMP_PKG", line 45
ORA-06512: at line 1

EMP_PKG.ADD_EMPLOYEE 프로시저는 기본 급여 $1,000와 기본 직무 ID SA_REP를 사용하는 
오버로드 버전을 호출하기 때문에 트리거에 예외가 발생한다.

2) 115 사원의 급여를 $2,000로 갱신한다. 별도의 UPDATE 작업에서 사원의 직무 ID를 HR_REP로 변경한다. 
   각 경우에 어떤 결과가 나타나는가?

UPDATE employees
SET salary = 2000
WHERE employee_id = 115;

UPDATE employees
       *
ERROR at line 1:
ORA-20100: Invalid salary $2000. Salaries for job PU_CLERK must be between
$2500 and $5500
ORA-06512: at "HR.CHECK_SALARY", line 10
ORA-06512: at "HR.CHECK_SALARY_TRG", line 2
ORA-04088: error during execution of trigger 'HR.CHECK_SALARY_TRG'

UPDATE employees
SET job_id = 'HR_REP'
WHERE employee_id = 115;

UPDATE employees
       *
ERROR at line 1:
ORA-20100: Invalid salary $3100. Salaries for job HR_REP must be between $4000
and $9000
ORA-06512: at "HR.CHECK_SALARY", line 10
ORA-06512: at "HR.CHECK_SALARY_TRG", line 2
ORA-04088: error during execution of trigger 'HR.CHECK_SALARY_TRG'

첫번째 UPDATE 문에서는 급여가 $2,000로 갱신되지 않는다. 
사원 115의 새로운 급여가 PU_CLERK 직무에 허용된 최소 급여보다 적기 때문에 
급여 검사 트리거 규칙이 UPDATE 작업에 실패한다.

두번째 UPDATE 문에서는 현재 사원의 급여 $3,100가 
새 직무 HR_REP의 최소 급여보다 적기 때문에 사원의 직무가 변경되지 않는다.

3) 사원 115의 급여를 $2,800로 갱신한다. 어떤 결과가 나타나는가?

UPDATE employees
SET salary = 2800
WHERE employee_id = 115;

새 급여가 현재 직무 ID의 허용 범위 내에 있기 때문에 UPDATE 작업이 성공한다.


3. 직무 ID나 급여 값이 실제로 변경된 경우에만 실행되도록 CHECK_SALARY_TRG 트리거를 갱신한다.

1) JOB_ID 또는 SALARY 값이 변경되었는지 여부를 확인하도록 WHEN 절을 사용하여 업무 규칙을 구현한다.
주: INSERT 작업이 수행될 경우 조건이 OLD.column_name 값의 NULL을 처리하도록 지정한다. 
그렇지 않으면 INSERT 작업이 실패하게 된다.

CREATE OR REPLACE TRIGGER check_salary_trg
BEFORE INSERT OR UPDATE OF job_id, salary
ON employees FOR EACH ROW
WHEN (new.job_id <> NVL(old.job_id,'?') OR
    new.salary <> NVL(old.salary,0))
BEGIN
    check_salary(:new.job_id, :new.salary);
END;
/

2) 파라미터 값 first_name='Eleanor', last name='Beh', email='EBEH', 
   job='IT_PROG', sal=5000으로 EMP_PKG.ADD_EMPLOYEE 프로시저를 실행하여 트리거를 테스트한다.

BEGIN
  emp_pkg.add_employee('Eleanor', 'Beh', 'EBEH',
    job => 'IT_PROG', sal => 5000);
END;
/

3) 직무가 IT_PROG인 사원의 급여를 $2,000씩 인상하여 갱신한다. 어떤 결과가 나타나는가?

UPDATE employees
SET salary = salary + 2000
WHERE job_id = 'IT_PROG';

UPDATE employees
       *
ERROR at line 1:
ORA-20100: Invalid salary $11000. Salaries for job IT_PROG must be between
$4000 and $10000
ORA-06512: at "HR.CHECK_SALARY", line 10
ORA-06512: at "HR.CHECK_SALARY_TRG", line 2
ORA-04088: error during execution of trigger 'HR.CHECK_SALARY_TRG'

지정된 직무 유형에 속하는 사원의 급여가 해당 직무 유형의 최대 급여를 초과한다. 
IT_PROG 직무 유형에 속하는 사원의 급여가 갱신되지 않는다.

4) Eleanor Beh의 급여를 $9,000로 갱신한다.
힌트: WHERE 절의 subquery와 함께 UPDATE 문을 사용한다. 어떤 결과가 나타나는가?

UPDATE employees
SET salary = 9000
WHERE employee_id = (SELECT employee_id
FROM employees
WHERE last_name = 'Beh');

급여가 이 사원의 직무 유형에 대해 적합하기 때문에 UPDATE 작업이 성공한다.

5) subquery를 포함한 다른 UPDATE 문을 사용하여 Eleanor Beh의 직무를 ST_MAN으로 변경한다. 
   어떤 결과가 나타나는가?

UPDATE employees
set job_id = 'ST_MAN'
WHERE employee_id = (SELECT employee_id
FROM employees
WHERE last_name = 'Beh');

UPDATE employees
       *
ERROR at line 1:
ORA-20100: Invalid salary $9000. Salaries for job ST_MAN must be between $5500
and $8500
ORA-06512: at "HR.CHECK_SALARY", line 10
ORA-06512: at "HR.CHECK_SALARY_TRG", line 2
ORA-04088: error during execution of trigger 'HR.CHECK_SALARY_TRG'

새 직무 유형의 최대 급여가 이 사원의 현재 급여보다 적다. 따라서 UPDATE 작업은 실패한다.


4. 업무 시간 동안 사원이 삭제되지 않게 하라는 요청을 받았다.

1) 평일 업무 시간(오전 9:00 - 오후 6:00) 중에는 행이 삭제되지 않도록 하는 
   DELETE_EMP_TRG라는 문장 트리거를 EMPLOYEES 테이블에 작성한다.

CREATE OR REPLACE TRIGGER delete_emp_trg
BEFORE DELETE ON employees
DECLARE
  the_day VARCHAR2(3) := TO_CHAR(SYSDATE, 'DY');
  the_hour PLS_INTEGER := TO_NUMBER(TO_CHAR(SYSDATE, 'HH24'));
BEGIN
  IF (the_hour BETWEEN 9 AND 18) AND (the_day NOT IN ('SAT','SUN'))
  THEN
    RAISE_APPLICATION_ERROR(-20150,
      'Employee records cannot be deleted during the week 9am and 6pm');
  END IF;
END;
/

2) 소속 부서가 없는 JOB_ID가 SA_REP인 사원을 삭제해 본다.
  주: ID가 178인 Grant라는 사원이다.

DELETE FROM employees
WHERE job_id = 'SA_REP'
AND department_id IS NULL;

DELETE FROM employees
            *
ERROR at line 1:
ORA-20150: Employee records cannot be deleted during the week 9am and
6pm
ORA-06512: at "HR.DELETE_EMP_TRG", line 7
ORA-04088: error during execution of trigger 'HR.DELETE_EMP_TRG'


===============================
실습 28. 종속성 관리
===============================

1. add_employee 프로시저와 valid_deptid 함수를 포함하는 모든 종속성을 보여 주는 트리 구조를 생성한다.
주: add_employee 및 valid_deptid는 "함수 생성" 단원에서 생성했다. 

1) ?/rdbms/admin/ 폴더에 있는 utldtree.sql 스크립트를 로드하고 실행한다.

SQL> @?/rdbms/admin/utldtree.sql

2) add_employee 프로시저에 대해 deptree_fill 프로시저를 실행한다.

SQL> EXECUTE deptree_fill('PROCEDURE', USER, 'add_employee')

3) IDEPTREE 뷰를 query하여 결과를 확인한다.

SQL> SELECT * FROM IDEPTREE;

4) valid_deptid 함수에 대해 deptree_fill 프로시저를 실행한다.

SQL> EXECUTE deptree_fill('FUNCTION', USER, 'valid_deptid')

5) IDEPTREE 뷰를 query하여 결과를 확인한다.

SQL> SELECT * FROM IDEPTREE;

6) valid_deptid 함수에 대해 deptree_fill 프로시저를 실행한다.

SQL> EXECUTE deptree_fill('FUNCTION', USER, 'valid_deptid')

7) IDEPTREE 뷰를 query하여 결과를 확인한다.

SQL> SELECT * FROM IDEPTREE;


2. 유효하지 않은 객체를 동적으로 검증한다.

1) EMPLOYEES 테이블의 복사본을 만들고 이름을 EMPS로 지정한다.

SQL> CREATE TABLE emps AS
     SELECT * FROM employees;

2) EMPLOYEES 테이블을 변경하고 데이터 유형이 NUMBER(9,2)인 TOTSAL 열을 추가한다.

SQL> ALTER TABLE employees
     ADD (totsal NUMBER(9,2));

3) 모든 부적합한 객체의 이름, 유형, 상태를 표시하는 query를 실행한다.

SQL> SELECT object_name, object_type, status
     FROM USER_OBJECTS
     WHERE status = 'INVALID';


======================
수고 하셨습니다! ^-^
======================